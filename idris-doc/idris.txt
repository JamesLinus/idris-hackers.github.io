-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Idris is a general purpose language with full dependent types. It is
--   compiled, with eager evaluation. Dependent types allow types to be
--   predicated on values, meaning that some aspects of a program's
--   behaviour can be specified precisely in the type. The language is
--   closely related to Epigram and Agda. There is a tutorial at
--   <a>http://www.idris-lang.org/documentation</a>. Features include:
--   
--   <ul>
--   <li>Full dependent types with dependent pattern matching</li>
--   <li>where clauses, with rule, simple case expressions, pattern
--   matching let and lambda bindings</li>
--   <li>Type classes, monad comprehensions</li>
--   <li>do notation, idiom brackets, syntactic conveniences for lists,
--   tuples, dependent pairs</li>
--   <li>Totality checking</li>
--   <li>Coinductive types</li>
--   <li>Indentation significant syntax, extensible syntax</li>
--   <li>Tactic based theorem proving (influenced by Coq)</li>
--   <li>Cumulative universes</li>
--   <li>Simple foreign function interface (to C)</li>
--   <li>Hugs style interactive environment</li>
--   </ul>
@package idris
@version 0.9.10

module IRTS.Java.Pom
pomString :: String -> String -> [String] -> String

module Util.Net
listenOnLocalhost :: PortID -> IO Socket

module Idris.Help
data CmdArg

-- | The command takes an expression
ExprArg :: CmdArg

-- | The command takes a name
NameArg :: CmdArg

-- | The command takes a file
FileArg :: CmdArg

-- | The command takes a module name
ModuleArg :: CmdArg

-- | The command takes an option
OptionArg :: CmdArg

-- | The command takes a metavariable
MetaVarArg :: CmdArg

-- | The command is the colour-setting command
ColourArg :: CmdArg

-- | No completion (yet!?)
NoArg :: CmdArg

-- | do not use
SpecialHeaderArg :: CmdArg
help :: [([String], CmdArg, String)]

-- | Use these for completion, but don't show them in :help
extraHelp :: [([String], CmdArg, String)]
instance Show CmdArg

module Idris.Colours
data IdrisColour
IdrisColour :: Maybe Color -> Bool -> Bool -> Bool -> Bool -> IdrisColour
colour :: IdrisColour -> Maybe Color
vivid :: IdrisColour -> Bool
underline :: IdrisColour -> Bool
bold :: IdrisColour -> Bool
italic :: IdrisColour -> Bool
data ColourTheme
ColourTheme :: IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> IdrisColour -> ColourTheme
keywordColour :: ColourTheme -> IdrisColour
boundVarColour :: ColourTheme -> IdrisColour
implicitColour :: ColourTheme -> IdrisColour
functionColour :: ColourTheme -> IdrisColour
typeColour :: ColourTheme -> IdrisColour
dataColour :: ColourTheme -> IdrisColour
promptColour :: ColourTheme -> IdrisColour
defaultTheme :: ColourTheme
colouriseKwd :: ColourTheme -> String -> String
colouriseBound :: ColourTheme -> String -> String
colouriseImplicit :: ColourTheme -> String -> String
colouriseType :: ColourTheme -> String -> String
colouriseFun :: ColourTheme -> String -> String
colouriseData :: ColourTheme -> String -> String
colourisePrompt :: ColourTheme -> String -> String
data ColourType
KeywordColour :: ColourType
BoundVarColour :: ColourType
ImplicitColour :: ColourType
FunctionColour :: ColourType
TypeColour :: ColourType
DataColour :: ColourType
PromptColour :: ColourType
instance Eq IdrisColour
instance Show IdrisColour
instance Eq ColourTheme
instance Show ColourTheme
instance Eq ColourType
instance Show ColourType
instance Bounded ColourType
instance Enum ColourType

module Util.Pretty
class Sized a
size :: Sized a => a -> Int
breakingSize :: Int
nestingSize :: Int
class Pretty a
pretty :: Pretty a => a -> Doc
instance Pretty a => Pretty [a]
instance Pretty ()
instance Sized a => Sized [a]
instance (Sized a, Sized b) => Sized (a, b)

module Paths_idris
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath


-- | Platform-specific dynamic linking support. Add new platforms to this
--   file through conditional compilation.
module Util.DynamicLinker
data DynamicLib
Lib :: String -> () -> DynamicLib
lib_name :: DynamicLib -> String
lib_handle :: DynamicLib -> ()
tryLoadLib :: String -> IO (Maybe DynamicLib)
instance Eq DynamicLib

module Util.System
tempfile :: IO (FilePath, Handle)
withTempdir :: String -> (FilePath -> IO a) -> IO a
getTargetDir :: IO String
getCC :: IO String
getLibFlags :: IO [Char]
getIdrisLibDir :: IO FilePath
getIncFlags :: IO [Char]
rmFile :: FilePath -> IO ()
getMvn :: IO String
getExecutablePom :: IO FilePath
catchIO :: IO a -> (IOError -> IO a) -> IO a


-- | TT is the core language of Idris. The language has:
--   
--   <ul>
--   <li>Full dependent types</li>
--   <li>A hierarchy of universes, with cumulativity: Type : Type1, Type1 :
--   Type2, ...</li>
--   <li>Pattern matching letrec binding</li>
--   <li>(primitive types defined externally)</li>
--   </ul>
--   
--   Some technical stuff:
--   
--   <ul>
--   <li>Typechecker is kept as simple as possible - no unification, just a
--   checker for incomplete terms.</li>
--   <li>We have a simple collection of tactics which we use to elaborate
--   source programs with implicit syntax into fully explicit terms.</li>
--   </ul>
module Core.TT
data Option
TTypeInTType :: Option
CheckConv :: Option

-- | Source location. These are typically produced by the parser
--   <a>getFC</a>
data FC
FC :: String -> Int -> Int -> FC

-- | Filename
fc_fname :: FC -> String

-- | Line number
fc_line :: FC -> Int

-- | Column number
fc_column :: FC -> Int

-- | FC with equality
newtype FC'
FC' :: FC -> FC'
unwrapFC :: FC' -> FC

-- | Empty source location
emptyFC :: FC

-- | Source location with file only
fileFC :: String -> FC
data Err
Msg :: String -> Err
InternalMsg :: String -> Err
CantUnify :: Bool -> Term -> Term -> Err -> [(Name, Type)] -> Int -> Err
InfiniteUnify :: Name -> Term -> [(Name, Type)] -> Err
CantConvert :: Term -> Term -> [(Name, Type)] -> Err
UnifyScope :: Name -> Name -> Term -> [(Name, Type)] -> Err
CantInferType :: String -> Err
NonFunctionType :: Term -> Term -> Err
CantIntroduce :: Term -> Err
NoSuchVariable :: Name -> Err
NoTypeDecl :: Name -> Err
NotInjective :: Term -> Term -> Term -> Err
CantResolve :: Term -> Err
CantResolveAlts :: [String] -> Err
IncompleteTerm :: Term -> Err
UniverseError :: Err
ProgramLineComment :: Err
Inaccessible :: Name -> Err
NonCollapsiblePostulate :: Name -> Err
AlreadyDefined :: Name -> Err
ProofSearchFail :: Err -> Err
NoRewriting :: Term -> Err
At :: FC -> Err -> Err
Elaborating :: String -> Name -> Err -> Err
ProviderError :: String -> Err
LoadingFailed :: String -> Err -> Err
score :: Err -> Int
data TC a
OK :: a -> TC a
Error :: Err -> TC a
tfail :: Err -> TC a
trun :: FC -> TC a -> TC a
discard :: Monad m => m a -> m ()
showSep :: String -> [String] -> String
pmap :: (t -> t1) -> (t, t) -> (t1, t1)
traceWhen :: Bool -> String -> a -> a

-- | Names are hierarchies of strings, describing scope (so no danger of
--   duplicate names, but need to be careful on lookup).
data Name

-- | User-provided name
UN :: String -> Name

-- | Root, namespaces
NS :: Name -> [String] -> Name

-- | Machine chosen names
MN :: Int -> String -> Name

-- | Name of somethng which is never used in scope
NErased :: Name

-- | Decorated function names
SN :: SpecialName -> Name
data SpecialName
WhereN :: Int -> Name -> Name -> SpecialName
InstanceN :: Name -> [String] -> SpecialName
ParentN :: Name -> String -> SpecialName
MethodN :: Name -> SpecialName
CaseN :: Name -> SpecialName
showCG :: Name -> String

-- | Contexts allow us to map names to things. A root name maps to a
--   collection of things in different namespaces with that name.
type Ctxt a = Map Name (Map Name a)
emptyContext :: Map k a
tcname :: Name -> Bool
implicitable :: Name -> Bool
nsroot :: Name -> Name
addDef :: Name -> a -> Ctxt a -> Ctxt a

-- | Look up a name in the context, given an optional namespace. The name
--   (n) may itself have a (partial) namespace given.
--   
--   Rules for resolution:
--   
--   <ul>
--   <li>if an explicit namespace is given, return the names which match
--   it. If none match, return all names.</li>
--   <li>if the name has has explicit namespace given, return the names
--   which match it and ignore the given namespace.</li>
--   <li>otherwise, return all names.</li>
--   </ul>
lookupCtxtName :: Name -> Ctxt a -> [(Name, a)]
lookupCtxt :: Name -> Ctxt a -> [a]
lookupCtxtExact :: Name -> Ctxt a -> [a]
updateDef :: Name -> (a -> a) -> Ctxt a -> Ctxt a
toAlist :: Ctxt a -> [(Name, a)]
addAlist :: Show a => [(Name, a)] -> Ctxt a -> Ctxt a
data NativeTy
IT8 :: NativeTy
IT16 :: NativeTy
IT32 :: NativeTy
IT64 :: NativeTy
data IntTy
ITFixed :: NativeTy -> IntTy
ITNative :: IntTy
ITBig :: IntTy
ITChar :: IntTy
ITVec :: NativeTy -> Int -> IntTy
data ArithTy
ATInt :: IntTy -> ArithTy
ATFloat :: ArithTy
nativeTyWidth :: NativeTy -> Int

-- | <i>Deprecated: Non-total function, use nativeTyWidth and appropriate
--   casing </i>
intTyWidth :: IntTy -> Int
data Const
I :: Int -> Const
BI :: Integer -> Const
Fl :: Double -> Const
Ch :: Char -> Const
Str :: String -> Const
B8 :: Word8 -> Const
B16 :: Word16 -> Const
B32 :: Word32 -> Const
B64 :: Word64 -> Const
B8V :: (Vector Word8) -> Const
B16V :: (Vector Word16) -> Const
B32V :: (Vector Word32) -> Const
B64V :: (Vector Word64) -> Const
AType :: ArithTy -> Const
StrType :: Const
PtrType :: Const
VoidType :: Const
Forgot :: Const
data Raw
Var :: Name -> Raw
RBind :: Name -> (Binder Raw) -> Raw -> Raw
RApp :: Raw -> Raw -> Raw
RType :: Raw
RForce :: Raw -> Raw
RConstant :: Const -> Raw

-- | All binding forms are represented in a unform fashion.
data Binder b
Lam :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
Pi :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
Let :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
NLet :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
Hole :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
GHole :: Int -> b -> Binder b
envlen :: Binder b -> Int

-- | type annotation for bound variable
binderTy :: Binder b -> b
Guess :: b -> b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b

-- | value for bound variable
binderVal :: Binder b -> b
PVar :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
PVTy :: b -> Binder b

-- | type annotation for bound variable
binderTy :: Binder b -> b
fmapMB :: Monad m => (a -> m b) -> Binder a -> m (Binder b)
raw_apply :: Raw -> [Raw] -> Raw
raw_unapply :: Raw -> (Raw, [Raw])
data RawFun
RawFun :: Raw -> Raw -> RawFun
rtype :: RawFun -> Raw
rval :: RawFun -> Raw
data RawDatatype
RDatatype :: Name -> Raw -> [(Name, Raw)] -> RawDatatype
data RDef
RFunction :: RawFun -> RDef
RConst :: Raw -> RDef
RData :: RawDatatype -> RDef
type RProgram = [(Name, RDef)]

-- | Universe expressions for universe checking
data UExp

-- | universe variable
UVar :: Int -> UExp

-- | explicit universe level
UVal :: Int -> UExp

-- | Universe constraints
data UConstraint

-- | Strictly less than
ULT :: UExp -> UExp -> UConstraint

-- | Less than or equal to
ULE :: UExp -> UExp -> UConstraint
type UCs = (Int, [UConstraint])
data NameType
Bound :: NameType
Ref :: NameType

-- | Data constructor; Ints are tag and arity
DCon :: Int -> Int -> NameType

-- | Type constructor; Ints are tag and arity
TCon :: Int -> Int -> NameType

-- | Terms in the core language
data TT n

-- | named references
P :: NameType -> n -> (TT n) -> TT n

-- | a resolved de Bruijn-indexed variable
V :: Int -> TT n

-- | a binding
Bind :: n -> (Binder (TT n)) -> (TT n) -> TT n

-- | function, function type, arg
App :: (TT n) -> (TT n) -> TT n

-- | constant
Constant :: Const -> TT n

-- | argument projection; runtime only (-1) is a special case for 'subtract
--   one from BI'
Proj :: (TT n) -> Int -> TT n

-- | an erased term
Erased :: TT n

-- | special case for totality checking
Impossible :: TT n

-- | the type of types at some level
TType :: UExp -> TT n
class TermSize a
termsize :: TermSize a => Name -> a -> Int
type EnvTT n = [(n, Binder (TT n))]
data Datatype n
Data :: n -> Int -> (TT n) -> [(n, TT n)] -> Datatype n
d_typename :: Datatype n -> n
d_typetag :: Datatype n -> Int
d_type :: Datatype n -> (TT n)
d_cons :: Datatype n -> [(n, TT n)]

-- | A term is injective iff it is a data constructor, type constructor,
--   constant, the type Type, pi-binding, or an application of an injective
--   term.
isInjective :: TT n -> Bool

-- | Count the number of instances of a de Bruijn index in a term
vinstances :: Int -> TT n -> Int
instantiate :: TT n -> TT n -> TT n
substV :: TT n -> TT n -> TT n
explicitNames :: TT n -> TT n
pToV :: Eq n => n -> TT n -> TT n
pToV' :: Eq n => n -> Int -> TT n -> TT n
addBinder :: TT n -> TT n

-- | Convert several names. First in the list comes out as V 0
pToVs :: Eq n => [n] -> TT n -> TT n
vToP :: TT n -> TT n
finalise :: Eq n => TT n -> TT n
subst :: Eq n => n -> TT n -> TT n -> TT n
substNames :: Eq n => [(n, TT n)] -> TT n -> TT n
substTerm :: Eq n => TT n -> TT n -> TT n -> TT n
noOccurrence :: Eq n => n -> TT n -> Bool

-- | Returns all names used free in the term
freeNames :: Eq n => TT n -> [n]

-- | Return the arity of a (normalised) type
arity :: TT n -> Int

-- | Deconstruct an application; returns the function and a list of
--   arguments
unApply :: TT n -> (TT n, [TT n])
mkApp :: TT n -> [TT n] -> TT n
forget :: TT Name -> Raw
bindAll :: [(n, Binder (TT n))] -> TT n -> TT n
bindTyArgs :: (TT n -> Binder (TT n)) -> [(n, TT n)] -> TT n -> TT n
getArgTys :: TT n -> [(n, TT n)]
getRetTy :: TT n -> TT n
uniqueName :: Name -> [Name] -> Name
uniqueBinders :: [Name] -> TT Name -> TT Name
nextName :: Name -> Name
type Term = TT Name
type Type = Term
type Env = EnvTT Name
newtype WkEnvTT n
Wk :: (EnvTT n) -> WkEnvTT n
type WkEnv = WkEnvTT Name
itBitsName :: NativeTy -> [Char]
showEnv :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> [Char]
showEnvDbg :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> [Char]
prettyEnv :: (Eq a, Show a, Pretty a) => [(a, Binder (TT a))] -> TT a -> Doc
showEnv' :: (Eq a, Show a) => [(a, Binder (TT a))] -> TT a -> Bool -> [Char]

-- | Check whether a term has any holes in it - impure if so
pureTerm :: TT Name -> Bool

-- | Weaken a term by adding i to each de Bruijn index (i.e. lift it over i
--   bindings)
weakenTm :: Int -> TT n -> TT n

-- | Weaken an environment so that all the de Bruijn indices are correct
--   according to the latest bound variable
weakenEnv :: EnvTT n -> EnvTT n
weakenTmEnv :: Int -> EnvTT n -> EnvTT n
orderPats :: Term -> Term
instance Eq Option
instance Eq SpecialName
instance Ord SpecialName
instance Eq Name
instance Ord Name
instance Show NativeTy
instance Eq NativeTy
instance Ord NativeTy
instance Enum NativeTy
instance Show IntTy
instance Eq IntTy
instance Ord IntTy
instance Show ArithTy
instance Eq ArithTy
instance Ord ArithTy
instance Eq Const
instance Ord Const
instance Show b => Show (Binder b)
instance Eq b => Eq (Binder b)
instance Ord b => Ord (Binder b)
instance Functor Binder
instance Show Raw
instance Eq Raw
instance Show RawFun
instance Show RawDatatype
instance Show RDef
instance Eq UExp
instance Ord UExp
instance Eq UConstraint
instance Show NameType
instance Ord NameType
instance Ord n => Ord (TT n)
instance Functor TT
instance (Eq n, Show n) => Show (Datatype n)
instance Functor Datatype
instance Eq n => Eq (Datatype n)
instance Eq Err
instance Eq a => Eq (TC a)
instance Functor TC
instance Show Const
instance (Eq n, Show n) => Show (TT n)
instance Eq n => Eq (TT n)
instance Pretty a => Pretty (TT a)
instance Sized a => Sized (TT a)
instance TermSize (TT Name)
instance TermSize a => TermSize [a]
instance Eq NameType
instance Pretty NameType
instance Sized NameType
instance Show UConstraint
instance Show UExp
instance Binary UExp
instance Sized UExp
instance Sized a => Sized (Binder a)
instance Pretty Raw
instance Sized Raw
instance Pretty Const
instance Sized Const
instance Pretty ArithTy
instance Pretty NativeTy
instance Show SpecialName
instance Show Name
instance Pretty Name
instance Sized Name
instance MonadPlus TC
instance Monad TC
instance Show a => Show (TC a)
instance Pretty a => Pretty (TC a)
instance Error Err
instance Pretty Err
instance Show Err
instance Sized Err
instance Show FC
instance Sized FC
instance Eq FC'
instance Eq FC


-- | Check universe constraints.
module Core.Constraints

-- | Check that a list of universe constraints can be satisfied.
ucheck :: [(UConstraint, FC)] -> TC ()

module Core.CaseTree
data CaseDef
CaseDef :: [Name] -> !SC -> [Term] -> CaseDef
type SC = SC' Term
data SC' t

-- | invariant: lowest tags first
Case :: Name -> [CaseAlt' t] -> SC' t

-- | special case for projections
ProjCase :: t -> [CaseAlt' t] -> SC' t
STerm :: !t -> SC' t

-- | error message
UnmatchedCase :: String -> SC' t

-- | already checked to be impossible
ImpossibleCase :: SC' t
type CaseAlt = CaseAlt' Term
data CaseAlt' t
ConCase :: Name -> Int -> [Name] -> !(SC' t) -> CaseAlt' t

-- | reflection function
FnCase :: Name -> [Name] -> !(SC' t) -> CaseAlt' t
ConstCase :: Const -> !(SC' t) -> CaseAlt' t
SucCase :: Name -> !(SC' t) -> CaseAlt' t
DefaultCase :: !(SC' t) -> CaseAlt' t
data Phase
CompileTime :: Phase
RunTime :: Phase
type CaseTree = SC
simpleCase :: Bool -> Bool -> Bool -> Phase -> FC -> [([Name], Term, Term)] -> TC CaseDef
small :: Name -> [Name] -> SC -> Bool
namesUsed :: SC -> [Name]
findCalls :: SC -> [Name] -> [(Name, [[Name]])]
findUsedArgs :: SC -> [Name] -> [Name]
instance Show t => Show (CaseAlt' t)
instance Eq t => Eq (CaseAlt' t)
instance Ord t => Ord (CaseAlt' t)
instance Functor CaseAlt'
instance Eq t => Eq (SC' t)
instance Ord t => Ord (SC' t)
instance Functor SC'
instance Show CaseDef
instance Show Phase
instance Eq Phase
instance Show Pat
instance Show Partition
instance Show ConType
instance Eq ConType
instance Show Group
instance TermSize CaseAlt
instance TermSize SC
instance Show t => Show (SC' t)

module Core.Evaluate
normalise :: Context -> Env -> TT Name -> TT Name
normaliseTrace :: Bool -> Context -> Env -> TT Name -> TT Name

-- | Normalise fully type checked terms (so, assume all names/let bindings
--   resolved)
normaliseC :: Context -> Env -> TT Name -> TT Name
normaliseAll :: Context -> Env -> TT Name -> TT Name

-- | Simplify for run-time (i.e. basic inlining)
rt_simplify :: Context -> Env -> TT Name -> TT Name

-- | Like normalise, but we only reduce functions that are marked as okay
--   to inline (and probably shouldn't reduce lets?) 20130908: now only
--   used to reduce for totality checking. Inlining should be done
--   elsewhere.
simplify :: Context -> Env -> TT Name -> TT Name
specialise :: Context -> Env -> [(Name, Int)] -> TT Name -> TT Name

-- | Reduce a term to head normal form
hnf :: Context -> Env -> TT Name -> TT Name
convEq :: Context -> TT Name -> TT Name -> StateT UCs TC Bool
convEq' :: Context -> TT Name -> TT Name -> TC Bool

-- | A definition is either a simple function (just an expression with a
--   type), a constant, which could be a data or type constructor, an axiom
--   or as an yet undefined function, or an Operator. An Operator is a
--   function which explains how to reduce. A CaseOp is a function defined
--   by a simple case tree
data Def
Function :: !Type -> !Term -> Def
TyDecl :: NameType -> !Type -> Def
Operator :: Type -> Int -> ([Value] -> Maybe Value) -> Def
CaseOp :: CaseInfo -> !Type -> ![Either Term (Term, Term)] -> ![([Name], Term, Term)] -> !CaseDefs -> Def
data CaseInfo
CaseInfo :: Bool -> Bool -> CaseInfo
case_inlinable :: CaseInfo -> Bool
tc_dictionary :: CaseInfo -> Bool
data CaseDefs
CaseDefs :: !([Name], SC) -> !([Name], SC) -> !([Name], SC) -> !([Name], SC) -> CaseDefs
cases_totcheck :: CaseDefs -> !([Name], SC)
cases_compiletime :: CaseDefs -> !([Name], SC)
cases_inlined :: CaseDefs -> !([Name], SC)
cases_runtime :: CaseDefs -> !([Name], SC)
data Accessibility
Public :: Accessibility
Frozen :: Accessibility
Hidden :: Accessibility

-- | The result of totality checking
data Totality

-- | well-founded arguments
Total :: [Int] -> Totality

-- | productive
Productive :: Totality
Partial :: PReason -> Totality
Unchecked :: Totality

-- | Reasons why a function may not be total
data PReason
Other :: [Name] -> PReason
Itself :: PReason
NotCovering :: PReason
NotPositive :: PReason
UseUndef :: Name -> PReason
BelieveMe :: PReason
Mutual :: [Name] -> PReason
NotProductive :: PReason

-- | Contexts used for global definitions and for proof state. They contain
--   universe constraints and existing definitions.
data Context

-- | The initial empty context
initContext :: Context

-- | Get the definitions from a context
ctxtAlist :: Context -> [(Name, Def)]
uconstraints :: Context -> [UConstraint]
next_tvar :: Context -> Int
addToCtxt :: Name -> Term -> Type -> Context -> Context
setAccess :: Name -> Accessibility -> Context -> Context
setTotal :: Name -> Totality -> Context -> Context
addCtxtDef :: Name -> Def -> Context -> Context
addTyDecl :: Name -> NameType -> Type -> Context -> Context
addDatatype :: Datatype Name -> Context -> Context
addCasedef :: Name -> CaseInfo -> Bool -> Bool -> Bool -> Bool -> [Either Term (Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> [([Name], Term, Term)] -> Type -> Context -> Context
simplifyCasedef :: Name -> Context -> Context
addOperator :: Name -> Type -> Int -> ([Value] -> Maybe Value) -> Context -> Context
lookupNames :: Name -> Context -> [Name]
lookupTy :: Name -> Context -> [Type]
lookupP :: Name -> Context -> [Term]
lookupDef :: Name -> Context -> [Def]
lookupDefAcc :: Name -> Bool -> Context -> [(Def, Accessibility)]
lookupVal :: Name -> Context -> [Value]
lookupTotal :: Name -> Context -> [Totality]
lookupNameTotal :: Name -> Context -> [(Name, Totality)]
lookupTyEnv :: Name -> Env -> Maybe (Int, Type)
isDConName :: Name -> Context -> Bool
isTConName :: Name -> Context -> Bool
isConName :: Name -> Context -> Bool
isFnName :: Name -> Context -> Bool

-- | A HOAS representation of values
data Value
VP :: NameType -> Name -> Value -> Value
VV :: Int -> Value
VBind :: Bool -> Name -> (Binder Value) -> (Value -> Eval Value) -> Value
VBLet :: Int -> Name -> Value -> Value -> Value -> Value
VApp :: Value -> Value -> Value
VType :: UExp -> Value
VErased :: Value
VImpossible :: Value
VConstant :: Const -> Value
VProj :: Value -> Int -> Value
VTmp :: Int -> Value
class Quote a
quote :: Quote a => Int -> a -> Eval (TT Name)
initEval :: EvalState
instance Show EvalState
instance Show EvalOpt
instance Eq EvalOpt
instance Show Accessibility
instance Eq Accessibility
instance Show PReason
instance Eq PReason
instance Eq Totality
instance Show Context
instance Show Totality
instance Binary (a -> b)
instance Show Def
instance Quote Value
instance Eq Value
instance Show (a -> b)
instance Show Value

module Core.Typecheck
convertsC :: Context -> Env -> Term -> Term -> StateT UCs TC ()
converts :: Context -> Env -> Term -> Term -> TC ()
errEnv :: [(t, Binder t1)] -> [(t, t1)]
isType :: Context -> Env -> Term -> TC ()
recheck :: Context -> Env -> Raw -> Term -> TC (Term, Type, UCs)
check :: Context -> Env -> Raw -> TC (Term, Type)
check' :: Bool -> Context -> Env -> Raw -> StateT UCs TC (Term, Type)
checkProgram :: Context -> RProgram -> TC Context

module Core.Unify
match_unify :: Context -> Env -> TT Name -> TT Name -> [Name] -> [Name] -> TC [(Name, TT Name)]
unify :: Context -> Env -> TT Name -> TT Name -> [Name] -> [Name] -> TC ([(Name, TT Name)], Fails)
type Fails = [(TT Name, TT Name, Env, Err)]
instance Show UInfo

module Core.ProofState
data ProofState
PS :: Name -> [Name] -> [Name] -> Int -> Term -> Type -> [Name] -> (Name, [(Name, Term)]) -> [(Name, Term)] -> Maybe (Name, Term) -> Fails -> [Name] -> [Name] -> [Name] -> Maybe ProofState -> Context -> String -> Bool -> Bool -> ProofState
thname :: ProofState -> Name
holes :: ProofState -> [Name]
usedns :: ProofState -> [Name]
nextname :: ProofState -> Int
pterm :: ProofState -> Term
ptype :: ProofState -> Type
dontunify :: ProofState -> [Name]
unified :: ProofState -> (Name, [(Name, Term)])
notunified :: ProofState -> [(Name, Term)]
solved :: ProofState -> Maybe (Name, Term)
problems :: ProofState -> Fails
injective :: ProofState -> [Name]
deferred :: ProofState -> [Name]
instances :: ProofState -> [Name]
previous :: ProofState -> Maybe ProofState
context :: ProofState -> Context
plog :: ProofState -> String
unifylog :: ProofState -> Bool
done :: ProofState -> Bool
newProof :: Name -> Context -> Type -> ProofState
envAtFocus :: ProofState -> TC Env
goalAtFocus :: ProofState -> TC (Binder Type)
data Tactic
Attack :: Tactic
Claim :: Name -> Raw -> Tactic
Reorder :: Name -> Tactic
Exact :: Raw -> Tactic
Fill :: Raw -> Tactic
MatchFill :: Raw -> Tactic
PrepFill :: Name -> [Name] -> Tactic
CompleteFill :: Tactic
Regret :: Tactic
Solve :: Tactic
StartUnify :: Name -> Tactic
EndUnify :: Tactic
Compute :: Tactic
ComputeLet :: Name -> Tactic
Simplify :: Tactic
HNF_Compute :: Tactic
EvalIn :: Raw -> Tactic
CheckIn :: Raw -> Tactic
Intro :: (Maybe Name) -> Tactic
IntroTy :: Raw -> (Maybe Name) -> Tactic
Forall :: Name -> Raw -> Tactic
LetBind :: Name -> Raw -> Raw -> Tactic
ExpandLet :: Name -> Term -> Tactic
Rewrite :: Raw -> Tactic
Equiv :: Raw -> Tactic
PatVar :: Name -> Tactic
PatBind :: Name -> Tactic
Focus :: Name -> Tactic
Defer :: Name -> Tactic
DeferType :: Name -> Raw -> [Name] -> Tactic
Instance :: Name -> Tactic
SetInjective :: Name -> Tactic
MoveLast :: Name -> Tactic
MatchProblems :: Tactic
UnifyProblems :: Tactic
ProofState :: Tactic
Undo :: Tactic
QED :: Tactic
data Goal
GD :: Env -> Binder Term -> Goal
premises :: Goal -> Env
goalType :: Goal -> Binder Term
processTactic :: Tactic -> ProofState -> TC (ProofState, String)
dropGiven :: Eq a => [a] -> [(a, TT a)] -> [a] -> [(a, TT a)]
keepGiven :: Eq a => [a] -> [(a, TT a)] -> [a] -> [(a, TT a)]
instance Show Tactic
instance Pretty ProofState
instance Show ProofState

module Core.Elaborate
data Command
Theorem :: Name -> Raw -> Command
Eval :: Raw -> Command
Quit :: Command
Print :: Name -> Command
Tac :: (Elab ()) -> Command
data ElabState aux
ES :: (ProofState, aux) -> String -> (Maybe (ElabState aux)) -> ElabState aux
type Elab' aux a = StateT (ElabState aux) TC a
type Elab a = Elab' () a
proof :: ElabState aux -> ProofState
proofFail :: Elab' aux a -> Elab' aux a
saveState :: Elab' aux ()
loadState :: Elab' aux ()
errAt :: String -> Name -> Elab' aux a -> Elab' aux a
erun :: FC -> Elab' aux a -> Elab' aux a
runElab :: aux -> Elab' aux a -> ProofState -> TC (a, ElabState aux)
execElab :: aux -> Elab' aux a -> ProofState -> TC (ElabState aux)
initElaborator :: Name -> Context -> Type -> ProofState
elaborate :: Context -> Name -> Type -> aux -> Elab' aux a -> TC (a, String)
updateAux :: (aux -> aux) -> Elab' aux ()
getAux :: Elab' aux aux
unifyLog :: Bool -> Elab' aux ()
processTactic' :: (MonadTrans t, MonadState (ElabState aux) (t TC)) => Tactic -> t TC ()
get_context :: Elab' aux Context
set_context :: Context -> Elab' aux ()
get_term :: Elab' aux Term
update_term :: (Term -> Term) -> Elab' aux ()
get_env :: Elab' aux Env
get_holes :: Elab' aux [Name]
get_probs :: Elab' aux Fails
goal :: Elab' aux Type
get_guess :: Elab' aux Type
get_type :: Raw -> Elab' aux Type
get_type_val :: Raw -> Elab' aux (Term, Type)
get_deferred :: Elab' aux [Name]
checkInjective :: (Term, Term, Term) -> Elab' aux ()
get_instances :: Elab' aux [Name]
unique_hole :: Name -> Elab' aux Name
unique_hole' :: Bool -> Name -> Elab' aux Name
uniqueNameCtxt :: Context -> Name -> [Name] -> Elab' aux Name
elog :: String -> Elab' aux ()
getLog :: Elab' aux String
attack :: Elab' aux ()
claim :: Name -> Raw -> Elab' aux ()
exact :: Raw -> Elab' aux ()
fill :: Raw -> Elab' aux ()
match_fill :: Raw -> Elab' aux ()
prep_fill :: Name -> [Name] -> Elab' aux ()
complete_fill :: Elab' aux ()
solve :: Elab' aux ()
start_unify :: Name -> Elab' aux ()
end_unify :: Elab' aux ()
regret :: Elab' aux ()
compute :: Elab' aux ()
computeLet :: Name -> Elab' aux ()
simplify :: Elab' aux ()
hnf_compute :: Elab' aux ()
eval_in :: Raw -> Elab' aux ()
check_in :: Raw -> Elab' aux ()
intro :: Maybe Name -> Elab' aux ()
introTy :: Raw -> Maybe Name -> Elab' aux ()
forall :: Name -> Raw -> Elab' aux ()
letbind :: Name -> Raw -> Raw -> Elab' aux ()
expandLet :: Name -> Term -> Elab' aux ()
rewrite :: Raw -> Elab' aux ()
equiv :: Raw -> Elab' aux ()
patvar :: Name -> Elab' aux ()
patbind :: Name -> Elab' aux ()
focus :: Name -> Elab' aux ()
movelast :: Name -> Elab' aux ()
matchProblems :: Elab' aux ()
unifyProblems :: Elab' aux ()
defer :: Name -> Elab' aux ()
deferType :: Name -> Raw -> [Name] -> Elab' aux ()
instanceArg :: Name -> Elab' aux ()
setinj :: Name -> Elab' aux ()
proofstate :: Elab' aux ()
reorder_claims :: Name -> Elab' aux ()
qed :: Elab' aux Term
undo :: Elab' aux ()
prepare_apply :: Raw -> [Bool] -> Elab' aux [Name]
apply :: Raw -> [(Bool, Int)] -> Elab' aux [Name]
match_apply :: Raw -> [(Bool, Int)] -> Elab' aux [Name]
apply' :: (Raw -> Elab' aux ()) -> Raw -> [(Bool, Int)] -> Elab' aux [Name]
apply2 :: Raw -> [Maybe (Elab' aux ())] -> Elab' aux ()
apply_elab :: Name -> [Maybe (Int, Elab' aux ())] -> Elab' aux ()
checkPiGoal :: Name -> Elab' aux ()
simple_app :: Elab' aux () -> Elab' aux () -> String -> Elab' aux ()
arg :: Name -> Name -> Elab' aux ()
no_errors :: Elab' aux () -> Elab' aux ()
try :: Elab' aux a -> Elab' aux a -> Elab' aux a
try' :: Elab' aux a -> Elab' aux a -> Bool -> Elab' aux a
tryWhen :: Bool -> Elab' aux a -> Elab' aux a -> Elab' aux a
tryAll :: [(Elab' aux a, String)] -> Elab' aux a
prunStateT :: Int -> Bool -> [a] -> StateT (ElabState t) TC t1 -> ElabState t -> TC ((t1, Int), ElabState t)
qshow :: Fails -> String
dumpprobs :: Show a => [(t, t1, t2, a)] -> [Char]
instance Show aux => Show (ElabState aux)

module IRTS.Lang
data LVar
Loc :: Int -> LVar
Glob :: Name -> LVar
data LExp
LV :: LVar -> LExp
LApp :: Bool -> LExp -> [LExp] -> LExp
LLazyApp :: Name -> [LExp] -> LExp
LLazyExp :: LExp -> LExp
LForce :: LExp -> LExp
LLet :: Name -> LExp -> LExp -> LExp
LLam :: [Name] -> LExp -> LExp
LProj :: LExp -> Int -> LExp
LCon :: Int -> Name -> [LExp] -> LExp
LCase :: LExp -> [LAlt] -> LExp
LConst :: Const -> LExp
LForeign :: FLang -> FType -> String -> [(FType, LExp)] -> LExp
LOp :: PrimFn -> [LExp] -> LExp
LNothing :: LExp
LError :: String -> LExp
data PrimFn
LPlus :: ArithTy -> PrimFn
LMinus :: ArithTy -> PrimFn
LTimes :: ArithTy -> PrimFn
LUDiv :: IntTy -> PrimFn
LSDiv :: ArithTy -> PrimFn
LURem :: IntTy -> PrimFn
LSRem :: ArithTy -> PrimFn
LAnd :: IntTy -> PrimFn
LOr :: IntTy -> PrimFn
LXOr :: IntTy -> PrimFn
LCompl :: IntTy -> PrimFn
LSHL :: IntTy -> PrimFn
LLSHR :: IntTy -> PrimFn
LASHR :: IntTy -> PrimFn
LEq :: ArithTy -> PrimFn
LLt :: IntTy -> PrimFn
LLe :: IntTy -> PrimFn
LGt :: IntTy -> PrimFn
LGe :: IntTy -> PrimFn
LSLt :: ArithTy -> PrimFn
LSLe :: ArithTy -> PrimFn
LSGt :: ArithTy -> PrimFn
LSGe :: ArithTy -> PrimFn
LSExt :: IntTy -> IntTy -> PrimFn
LZExt :: IntTy -> IntTy -> PrimFn
LTrunc :: IntTy -> IntTy -> PrimFn
LStrConcat :: PrimFn
LStrLt :: PrimFn
LStrEq :: PrimFn
LStrLen :: PrimFn
LIntFloat :: IntTy -> PrimFn
LFloatInt :: IntTy -> PrimFn
LIntStr :: IntTy -> PrimFn
LStrInt :: IntTy -> PrimFn
LFloatStr :: PrimFn
LStrFloat :: PrimFn
LChInt :: IntTy -> PrimFn
LIntCh :: IntTy -> PrimFn
LPrintNum :: PrimFn
LPrintStr :: PrimFn
LReadStr :: PrimFn
LBitCast :: ArithTy -> ArithTy -> PrimFn
LFExp :: PrimFn
LFLog :: PrimFn
LFSin :: PrimFn
LFCos :: PrimFn
LFTan :: PrimFn
LFASin :: PrimFn
LFACos :: PrimFn
LFATan :: PrimFn
LFSqrt :: PrimFn
LFFloor :: PrimFn
LFCeil :: PrimFn
LMkVec :: NativeTy -> Int -> PrimFn
LIdxVec :: NativeTy -> Int -> PrimFn
LUpdateVec :: NativeTy -> Int -> PrimFn
LStrHead :: PrimFn
LStrTail :: PrimFn
LStrCons :: PrimFn
LStrIndex :: PrimFn
LStrRev :: PrimFn
LStdIn :: PrimFn
LStdOut :: PrimFn
LStdErr :: PrimFn
LFork :: PrimFn
LPar :: PrimFn
LVMPtr :: PrimFn
LNullPtr :: PrimFn
LNoOp :: PrimFn
data FCallType
FStatic :: FCallType
FObject :: FCallType
FConstructor :: FCallType
data FLang
LANG_C :: FLang
LANG_JAVA :: FCallType -> FLang
data FType
FArith :: ArithTy -> FType
FFunction :: FType
FFunctionIO :: FType
FString :: FType
FUnit :: FType
FPtr :: FType
FAny :: FType
data LAlt
LConCase :: Int -> Name -> [Name] -> LExp -> LAlt
LConstCase :: Const -> LExp -> LAlt
LDefaultCase :: LExp -> LAlt
data LDecl
LFun :: [LOpt] -> Name -> [Name] -> LExp -> LDecl
LConstructor :: Name -> Int -> Int -> LDecl
type LDefs = Ctxt LDecl
data LOpt
Inline :: LOpt
NoInline :: LOpt
addTags :: Int -> [(Name, LDecl)] -> (Int, [(Name, LDecl)])
data LiftState
LS :: Name -> Int -> [(Name, LDecl)] -> LiftState
lname :: Name -> Int -> Name
liftAll :: [(Name, LDecl)] -> [(Name, LDecl)]
lambdaLift :: Name -> LDecl -> [(Name, LDecl)]
getNextName :: State LiftState Name
addFn :: Name -> LDecl -> State LiftState ()
lift :: [Name] -> LExp -> State LiftState LExp
usedArg :: Eq t => [t] -> t -> [t]
usedIn :: [Name] -> LExp -> [Name]
instance Show LVar
instance Eq LVar
instance Show PrimFn
instance Eq PrimFn
instance Show FCallType
instance Eq FCallType
instance Show FLang
instance Eq FLang
instance Show FType
instance Eq FType
instance Show LAlt
instance Eq LAlt
instance Eq LExp
instance Show LOpt
instance Eq LOpt
instance Show LDecl
instance Eq LDecl
instance Show LExp

module Idris.IdeSlave
parseMessage :: String -> Either Err (SExp, Integer)
convSExp :: SExpable a => String -> a -> Integer -> String
data IdeSlaveCommand
REPLCompletions :: String -> IdeSlaveCommand
Interpret :: String -> IdeSlaveCommand
TypeOf :: String -> IdeSlaveCommand
CaseSplit :: Int -> String -> IdeSlaveCommand
AddClause :: Int -> String -> IdeSlaveCommand
AddProofClause :: Int -> String -> IdeSlaveCommand
AddMissing :: Int -> String -> IdeSlaveCommand
MakeWithBlock :: Int -> String -> IdeSlaveCommand
ProofSearch :: Int -> String -> [String] -> IdeSlaveCommand
LoadFile :: String -> IdeSlaveCommand
sexpToCommand :: SExp -> Maybe IdeSlaveCommand
data SExp
SexpList :: [SExp] -> SExp
StringAtom :: String -> SExp
BoolAtom :: Bool -> SExp
IntegerAtom :: Integer -> SExp
SymbolAtom :: String -> SExp
class SExpable a
toSExp :: SExpable a => a -> SExp
instance [incoherent] Eq SExp
instance [incoherent] Show SExp
instance [incoherent] Show IdeSlaveCommand
instance [incoherent] (SExpable a, SExpable b, SExpable c) => SExpable (a, b, c)
instance [incoherent] (SExpable a, SExpable b) => SExpable (a, b)
instance [incoherent] SExpable a => SExpable [a]
instance [incoherent] SExpable a => SExpable (Maybe a)
instance [incoherent] SExpable Name
instance [incoherent] SExpable Int
instance [incoherent] SExpable Integer
instance [incoherent] SExpable String
instance [incoherent] SExpable Bool
instance [incoherent] SExpable SExp

module Idris.Unlit
unlit :: FilePath -> String -> TC String

module IRTS.Java.JTypes
charType :: Type
byteType :: Type
shortType :: Type
integerType :: Type
longType :: Type
doubleType :: Type
array :: Type -> Type
objectType :: Type
bigIntegerType :: Type
stringType :: Type
threadType :: Type
callableType :: Type
voidType :: Type
box :: Type -> Type
isFloating :: Type -> Bool
isPrimitive :: Type -> Bool
isArray :: Type -> Bool
isString :: Type -> Bool
idrisClosureType :: Type
idrisTailCallClosureType :: Type
idrisObjectType :: Type
foreignWrapperType :: Type
primFnType :: Type
arraysType :: Type
mathType :: Type
exceptionType :: Type
runtimeExceptionType :: Type
nativeTyToJType :: NativeTy -> Type
intTyToJType :: IntTy -> Type
arithTyToJType :: ArithTy -> Type
localContextID :: Ident
localContext :: Exp
globalContextID :: Ident
globalContext :: Exp
newContextID :: Ident
newContext :: Exp
contextArray :: LVar -> Exp
contextParam :: FormalParam
constType :: Const -> Type
foreignType :: FType -> Maybe Type
opName :: PrimFn -> String
sourceTypes :: PrimFn -> [Type]

module IRTS.Java.ASTBuilding
toClassType :: Type -> ClassType
toRefType :: Type -> RefType
class InvocationTarget a
(~>) :: InvocationTarget a => a -> String -> [Argument] -> Exp
class Callable a
call :: Callable a => a -> [Argument] -> Exp
(<>) :: Type -> Exp -> Exp
localVar :: Int -> Ident
(@!) :: Exp -> Int -> ArrayIndex
(@:=) :: Either ArrayIndex Ident -> Exp -> BlockStmt
(~&&~) :: Exp -> Exp -> Exp
(~==~) :: Exp -> Exp -> Exp
addToBlock :: [BlockStmt] -> Exp -> [BlockStmt]
jName :: String -> Name
jConst :: String -> Exp
jReturn :: Exp -> BlockStmt
jInt :: Int -> Exp
jString :: String -> Exp
simpleMethod :: [Modifier] -> Maybe Type -> String -> [FormalParam] -> Block -> Decl
declareFinalObjectArray :: Ident -> Maybe VarInit -> BlockStmt
arrayInitExps :: [Exp] -> VarInit
extendWithNull :: [Exp] -> Int -> [Exp]
closure :: Exp -> Exp
bigInteger :: String -> Exp
instance Callable Name
instance Callable Ident
instance Callable String
instance InvocationTarget Type
instance InvocationTarget Exp
instance InvocationTarget ClassType

module IRTS.Defunctionalise
data DExp
DV :: LVar -> DExp
DApp :: Bool -> Name -> [DExp] -> DExp
DLet :: Name -> DExp -> DExp -> DExp
DUpdate :: Name -> DExp -> DExp
DProj :: DExp -> Int -> DExp
DC :: Int -> Name -> [DExp] -> DExp
DCase :: DExp -> [DAlt] -> DExp
DChkCase :: DExp -> [DAlt] -> DExp
DConst :: Const -> DExp
DForeign :: FLang -> FType -> String -> [(FType, DExp)] -> DExp
DOp :: PrimFn -> [DExp] -> DExp
DNothing :: DExp
DError :: String -> DExp
data DAlt
DConCase :: Int -> Name -> [Name] -> DExp -> DAlt
DConstCase :: Const -> DExp -> DAlt
DDefaultCase :: DExp -> DAlt
data DDecl
DFun :: Name -> [Name] -> DExp -> DDecl
DConstructor :: Name -> Int -> Int -> DDecl
type DDefs = Ctxt DDecl
defunctionalise :: Int -> LDefs -> DDefs
getFn :: [(Name, LDecl)] -> [(Name, Int)]
addApps :: LDefs -> (Name, LDecl) -> State [Name] (Name, DDecl)
eEVAL :: DExp -> DExp
data EvalApply a
EvalCase :: (Name -> a) -> EvalApply a
ApplyCase :: a -> EvalApply a
toCons :: [Name] -> (Name, Int) -> [(Name, Int, EvalApply DAlt)]
mkApplyCase :: Name -> Int -> Int -> [(Name, Int, EvalApply DAlt)]
mkEval :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
mkApply :: [(Name, Int, EvalApply DAlt)] -> (Name, DDecl)
declare :: Int -> [(Name, Int, EvalApply DAlt)] -> [(Name, DDecl)]
genArgs :: Int -> [Name]
mkFnCon :: Show a => a -> Name
mkUnderCon :: Name -> Int -> Name
mkBigCase :: t -> Int -> DExp -> [DAlt] -> DExp
groupsOf :: Int -> [DAlt] -> [[DAlt]]
dumpDefuns :: DDefs -> String
instance Show DAlt
instance Eq DAlt
instance Eq DExp
instance Show DDecl
instance Eq DDecl
instance Show DExp

module IRTS.Simplified
data SExp
SV :: LVar -> SExp
SApp :: Bool -> Name -> [LVar] -> SExp
SLet :: LVar -> SExp -> SExp -> SExp
SUpdate :: LVar -> SExp -> SExp
SCon :: Int -> Name -> [LVar] -> SExp
SCase :: LVar -> [SAlt] -> SExp
SChkCase :: LVar -> [SAlt] -> SExp
SProj :: LVar -> Int -> SExp
SConst :: Const -> SExp
SForeign :: FLang -> FType -> String -> [(FType, LVar)] -> SExp
SOp :: PrimFn -> [LVar] -> SExp
SNothing :: SExp
SError :: String -> SExp
data SAlt
SConCase :: Int -> Int -> Name -> [Name] -> SExp -> SAlt
SConstCase :: Const -> SExp -> SAlt
SDefaultCase :: SExp -> SAlt
data SDecl
SFun :: Name -> [Name] -> Int -> SExp -> SDecl
hvar :: State (DDefs, Int) Int
ldefs :: State (DDefs, Int) DDefs
simplify :: Bool -> DExp -> State (DDefs, Int) SExp
sVar :: DExp -> StateT (DDefs, Int) Identity (LVar, Maybe SExp)
mkapp :: Monad m => ([LVar] -> SExp) -> [(LVar, Maybe SExp)] -> m SExp
mkfapp :: Monad m => ([(t, LVar)] -> SExp) -> [(t, (LVar, Maybe SExp))] -> m SExp
sAlt :: Bool -> DAlt -> StateT (DDefs, Int) Identity SAlt
checkDefs :: DDefs -> [(Name, DDecl)] -> TC [(Name, SDecl)]
lvar :: (Ord s, MonadState s m) => s -> m ()
scopecheck :: DDefs -> [(Name, Int)] -> SExp -> StateT Int TC SExp
instance Show SAlt
instance Show SExp
instance Show SDecl

module IRTS.CodegenCommon
data DbgLevel
NONE :: DbgLevel
DEBUG :: DbgLevel
TRACE :: DbgLevel
data OutputType
Raw :: OutputType
Object :: OutputType
Executable :: OutputType
MavenProject :: OutputType
environment :: String -> IO (Maybe String)
instance Eq DbgLevel
instance Eq OutputType
instance Show OutputType

module Idris.AbsSyntaxTree
data IOption
IOption :: Int -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Codegen -> OutputType -> FilePath -> [FilePath] -> String -> String -> Word -> [Opt] -> IOption
opt_logLevel :: IOption -> Int
opt_typecase :: IOption -> Bool
opt_typeintype :: IOption -> Bool
opt_coverage :: IOption -> Bool

-- | ^ show implicits
opt_showimp :: IOption -> Bool
opt_errContext :: IOption -> Bool
opt_repl :: IOption -> Bool
opt_verbose :: IOption -> Bool
opt_nobanner :: IOption -> Bool
opt_quiet :: IOption -> Bool
opt_codegen :: IOption -> Codegen
opt_outputTy :: IOption -> OutputType
opt_ibcsubdir :: IOption -> FilePath
opt_importdirs :: IOption -> [FilePath]
opt_triple :: IOption -> String
opt_cpu :: IOption -> String
opt_optLevel :: IOption -> Word
opt_cmdline :: IOption -> [Opt]
defaultOpts :: IOption
data LanguageExt
TypeProviders :: LanguageExt
ErrorReflection :: LanguageExt

-- | The output mode in use
data OutputMode
RawOutput :: OutputMode
IdeSlave :: Integer -> OutputMode

-- | The global state used in the Idris monad
data IState
IState :: Context -> [(UConstraint, FC)] -> [FixDecl] -> Ctxt [PArg] -> Ctxt [Bool] -> Ctxt ClassInfo -> Ctxt DSL -> Ctxt OptInfo -> Ctxt TypeInfo -> Ctxt ([([Name], Term, Term)], [PTerm]) -> Ctxt [FnOpt] -> Ctxt CGInfo -> Ctxt [Name] -> Ctxt String -> [(FC, Name)] -> [(FC, Name)] -> IOption -> Int -> [((FilePath, Int), PTerm)] -> [(Name, (Maybe Name, Int, Bool))] -> [Name] -> [(Term, Term)] -> [Syntax] -> [String] -> [FilePath] -> [(Name, (Int, PrimFn))] -> [(Codegen, FilePath)] -> [(Codegen, String)] -> [(Codegen, String)] -> [(Codegen, String)] -> [(Name, [String])] -> Maybe Int -> Maybe Name -> [Int] -> [Maybe Int] -> [(Name, Maybe Accessibility)] -> Accessibility -> Bool -> [IBCWrite] -> Maybe String -> [DynamicLib] -> [LanguageExt] -> OutputMode -> Bool -> ColourTheme -> Handle -> IState

-- | All the currently defined names and their terms
tt_ctxt :: IState -> Context

-- | A list of universe constraints and their corresponding source
--   locations
idris_constraints :: IState -> [(UConstraint, FC)]

-- | Currently defined infix operators
idris_infixes :: IState -> [FixDecl]
idris_implicits :: IState -> Ctxt [PArg]
idris_statics :: IState -> Ctxt [Bool]
idris_classes :: IState -> Ctxt ClassInfo
idris_dsls :: IState -> Ctxt DSL
idris_optimisation :: IState -> Ctxt OptInfo
idris_datatypes :: IState -> Ctxt TypeInfo

-- | list of lhs/rhs, and a list of missing clauses
idris_patdefs :: IState -> Ctxt ([([Name], Term, Term)], [PTerm])
idris_flags :: IState -> Ctxt [FnOpt]
idris_callgraph :: IState -> Ctxt CGInfo
idris_calledgraph :: IState -> Ctxt [Name]
idris_docstrings :: IState -> Ctxt String
idris_totcheck :: IState -> [(FC, Name)]
idris_defertotcheck :: IState -> [(FC, Name)]
idris_options :: IState -> IOption
idris_name :: IState -> Int

-- | Full application LHS on source line
idris_lineapps :: IState -> [((FilePath, Int), PTerm)]

-- | The currently defined but not proven metavariables
idris_metavars :: IState -> [(Name, (Maybe Name, Int, Bool))]
idris_coercions :: IState -> [Name]
idris_transforms :: IState -> [(Term, Term)]
syntax_rules :: IState -> [Syntax]
syntax_keywords :: IState -> [String]

-- | The imported modules
imported :: IState -> [FilePath]
idris_scprims :: IState -> [(Name, (Int, PrimFn))]
idris_objs :: IState -> [(Codegen, FilePath)]
idris_libs :: IState -> [(Codegen, String)]
idris_cgflags :: IState -> [(Codegen, String)]
idris_hdrs :: IState -> [(Codegen, String)]
proof_list :: IState -> [(Name, [String])]
errLine :: IState -> Maybe Int
lastParse :: IState -> Maybe Name
indent_stack :: IState -> [Int]
brace_stack :: IState -> [Maybe Int]
hide_list :: IState -> [(Name, Maybe Accessibility)]
default_access :: IState -> Accessibility
default_total :: IState -> Bool
ibc_write :: IState -> [IBCWrite]
compiled_so :: IState -> Maybe String
idris_dynamic_libs :: IState -> [DynamicLib]
idris_language_extensions :: IState -> [LanguageExt]
idris_outputmode :: IState -> OutputMode
idris_colourRepl :: IState -> Bool
idris_colourTheme :: IState -> ColourTheme
idris_outh :: IState -> Handle
data SizeChange
Smaller :: SizeChange
Same :: SizeChange
Bigger :: SizeChange
Unknown :: SizeChange
type SCGEntry = (Name, [Maybe (Int, SizeChange)])
data CGInfo
CGInfo :: [Name] -> [(Name, [[Name]])] -> [SCGEntry] -> [Name] -> [Int] -> CGInfo
argsdef :: CGInfo -> [Name]
calls :: CGInfo -> [(Name, [[Name]])]
scg :: CGInfo -> [SCGEntry]
argsused :: CGInfo -> [Name]
unusedpos :: CGInfo -> [Int]
primDefs :: [Name]
data IBCWrite
IBCFix :: FixDecl -> IBCWrite
IBCImp :: Name -> IBCWrite
IBCStatic :: Name -> IBCWrite
IBCClass :: Name -> IBCWrite
IBCInstance :: Bool -> Name -> Name -> IBCWrite
IBCDSL :: Name -> IBCWrite
IBCData :: Name -> IBCWrite
IBCOpt :: Name -> IBCWrite
IBCSyntax :: Syntax -> IBCWrite
IBCKeyword :: String -> IBCWrite
IBCImport :: FilePath -> IBCWrite
IBCObj :: Codegen -> FilePath -> IBCWrite
IBCLib :: Codegen -> String -> IBCWrite
IBCCGFlag :: Codegen -> String -> IBCWrite
IBCDyLib :: String -> IBCWrite
IBCHeader :: Codegen -> String -> IBCWrite
IBCAccess :: Name -> Accessibility -> IBCWrite
IBCTotal :: Name -> Totality -> IBCWrite
IBCFlags :: Name -> [FnOpt] -> IBCWrite
IBCTrans :: (Term, Term) -> IBCWrite
IBCCG :: Name -> IBCWrite
IBCDoc :: Name -> IBCWrite
IBCCoercion :: Name -> IBCWrite
IBCDef :: Name -> IBCWrite
IBCLineApp :: FilePath -> Int -> PTerm -> IBCWrite
idrisInit :: IState

-- | The monad for the main REPL - reading and processing files and
--   updating global state (hence the IO inner monad). type Idris = WriterT
--   [Either String (IO ())] (State IState a))
type Idris = StateT IState (ErrorT Err IO)
data Codegen
ViaC :: Codegen
ViaJava :: Codegen
ViaNode :: Codegen
ViaJavaScript :: Codegen
ViaLLVM :: Codegen
Bytecode :: Codegen

-- | REPL commands
data Command
Quit :: Command
Help :: Command
Eval :: PTerm -> Command
Check :: PTerm -> Command
DocStr :: Name -> Command
TotCheck :: Name -> Command
Reload :: Command
Load :: FilePath -> Command
ChangeDirectory :: FilePath -> Command
ModImport :: String -> Command
Edit :: Command
Compile :: Codegen -> String -> Command
Execute :: Command
ExecVal :: PTerm -> Command
Metavars :: Command
Prove :: Name -> Command
AddProof :: (Maybe Name) -> Command
RmProof :: Name -> Command
ShowProof :: Name -> Command
Proofs :: Command
Universes :: Command
LogLvl :: Int -> Command
Spec :: PTerm -> Command
HNF :: PTerm -> Command
TestInline :: PTerm -> Command
Defn :: Name -> Command
Info :: Name -> Command
Missing :: Name -> Command
DynamicLink :: FilePath -> Command
ListDynamic :: Command
Pattelab :: PTerm -> Command
DebugInfo :: Name -> Command
Search :: PTerm -> Command
CaseSplitAt :: Bool -> Int -> Name -> Command
AddClauseFrom :: Bool -> Int -> Name -> Command
AddProofClauseFrom :: Bool -> Int -> Name -> Command
AddMissing :: Bool -> Int -> Name -> Command
MakeWith :: Bool -> Int -> Name -> Command
DoProofSearch :: Bool -> Int -> Name -> [Name] -> Command
SetOpt :: Opt -> Command
UnsetOpt :: Opt -> Command
NOP :: Command
SetColour :: ColourType -> IdrisColour -> Command
ColourOn :: Command
ColourOff :: Command
data Opt
Filename :: String -> Opt
Ver :: Opt
Usage :: Opt
Quiet :: Opt
NoBanner :: Opt
ColourREPL :: Bool -> Opt
Ideslave :: Opt
ShowLibs :: Opt
ShowLibdir :: Opt
ShowIncs :: Opt
NoBasePkgs :: Opt
NoPrelude :: Opt
NoBuiltins :: Opt
NoREPL :: Opt
OLogging :: Int -> Opt
Output :: String -> Opt
TypeCase :: Opt
TypeInType :: Opt
DefaultTotal :: Opt
DefaultPartial :: Opt
WarnPartial :: Opt
NoCoverage :: Opt
ErrContext :: Opt
ShowImpl :: Opt
Verbose :: Opt
IBCSubDir :: String -> Opt
ImportDir :: String -> Opt
PkgBuild :: String -> Opt
PkgInstall :: String -> Opt
PkgClean :: String -> Opt
WarnOnly :: Opt
Pkg :: String -> Opt
BCAsm :: String -> Opt
DumpDefun :: String -> Opt
DumpCases :: String -> Opt
UseCodegen :: Codegen -> Opt
OutputTy :: OutputType -> Opt
Extension :: LanguageExt -> Opt
InterpretScript :: String -> Opt
TargetTriple :: String -> Opt
TargetCPU :: String -> Opt
OptLevel :: Word -> Opt
Client :: String -> Opt
data Fixity
Infixl :: Int -> Fixity
prec :: Fixity -> Int
Infixr :: Int -> Fixity
prec :: Fixity -> Int
InfixN :: Int -> Fixity
prec :: Fixity -> Int
PrefixN :: Int -> Fixity
prec :: Fixity -> Int
data FixDecl
Fix :: Fixity -> String -> FixDecl
data Static
Static :: Static
Dynamic :: Static
data Plicity
Imp :: Bool -> Static -> String -> Bool -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
pparam :: Plicity -> Bool
Exp :: Bool -> Static -> String -> Bool -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
pparam :: Plicity -> Bool
Constraint :: Bool -> Static -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pdocstr :: Plicity -> String
TacImp :: Bool -> Static -> PTerm -> String -> Plicity
plazy :: Plicity -> Bool
pstatic :: Plicity -> Static
pscript :: Plicity -> PTerm
pdocstr :: Plicity -> String
impl :: Plicity
expl :: Plicity
expl_param :: Plicity
constraint :: Plicity
tacimpl :: PTerm -> Plicity
data FnOpt
Inlinable :: FnOpt
TotalFn :: FnOpt
PartialFn :: FnOpt
Coinductive :: FnOpt
AssertTotal :: FnOpt
Dictionary :: FnOpt
Implicit :: FnOpt
CExport :: String -> FnOpt
Reflection :: FnOpt
Specialise :: [(Name, Maybe Int)] -> FnOpt
type FnOpts = [FnOpt]
inlinable :: FnOpts -> Bool
dictionary :: FnOpts -> Bool

-- | Top-level declarations such as compiler directives, definitions,
--   datatypes and typeclasses.
data PDecl' t

-- | Fixity declaration
PFix :: FC -> Fixity -> [String] -> PDecl' t

-- | Type declaration
PTy :: String -> SyntaxInfo -> FC -> FnOpts -> Name -> t -> PDecl' t

-- | Postulate
PPostulate :: String -> SyntaxInfo -> FC -> FnOpts -> Name -> t -> PDecl' t

-- | Pattern clause
PClauses :: FC -> FnOpts -> Name -> [PClause' t] -> PDecl' t

-- | Top level constant
PCAF :: FC -> Name -> t -> PDecl' t

-- | Data declaration. The Bool argument is True for codata.
PData :: String -> SyntaxInfo -> FC -> Bool -> (PData' t) -> PDecl' t

-- | Params block
PParams :: FC -> [(Name, t)] -> [PDecl' t] -> PDecl' t

-- | New namespace
PNamespace :: String -> [PDecl' t] -> PDecl' t

-- | Record declaration
PRecord :: String -> SyntaxInfo -> FC -> Name -> t -> String -> Name -> t -> PDecl' t

-- | Type class: arguments are documentation, syntax info, source location,
--   constraints, class name, parameters, method declarations
PClass :: String -> SyntaxInfo -> FC -> [t] -> Name -> [(Name, t)] -> [PDecl' t] -> PDecl' t

-- | Instance declaration: arguments are syntax info, source location,
--   constraints, class name, parameters, full instance type, optional
--   explicit name, and definitions
PInstance :: SyntaxInfo -> FC -> [t] -> Name -> [t] -> t -> (Maybe Name) -> [PDecl' t] -> PDecl' t

-- | DSL declaration
PDSL :: Name -> (DSL' t) -> PDecl' t

-- | Syntax definition
PSyntax :: FC -> Syntax -> PDecl' t

-- | Mutual block
PMutual :: FC -> [PDecl' t] -> PDecl' t

-- | Compiler directive. The parser inserts the corresponding action in the
--   Idris monad.
PDirective :: (Idris ()) -> PDecl' t

-- | Type provider. The first t is the type, the second is the term
PProvider :: SyntaxInfo -> FC -> Name -> t -> t -> PDecl' t

-- | Source-to-source transformation rule. If bool is True, lhs and rhs
--   must be convertible
PTransform :: FC -> Bool -> t -> t -> PDecl' t
type ElabD a = Elab' [PDecl] a

-- | One clause of a top-level definition. Term arguments to constructors
--   are:
--   
--   <ol>
--   <li>The whole application (missing for PClauseR and PWithR because
--   they're within a <a>with</a> clause)</li>
--   <li>The list of extra <tt>with</tt> patterns</li>
--   <li>The right-hand side</li>
--   <li>The where block (PDecl' t)</li>
--   </ol>
data PClause' t

-- | A normal top-level definition.
PClause :: FC -> Name -> t -> [t] -> t -> [PDecl' t] -> PClause' t
PWith :: FC -> Name -> t -> [t] -> t -> [PDecl' t] -> PClause' t
PClauseR :: FC -> [t] -> t -> [PDecl' t] -> PClause' t
PWithR :: FC -> [t] -> t -> [PDecl' t] -> PClause' t

-- | Data declaration
data PData' t

-- | Data declaration
PDatadecl :: Name -> t -> [(String, Name, t, FC)] -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | Type constructor
d_tcon :: PData' t -> t

-- | Constructors
d_cons :: PData' t -> [(String, Name, t, FC)]

-- | <a>Placeholder</a> for data whose constructors are defined later
PLaterdecl :: Name -> t -> PData' t

-- | The name of the datatype
d_name :: PData' t -> Name

-- | Type constructor
d_tcon :: PData' t -> t
type PDecl = PDecl' PTerm
type PData = PData' PTerm
type PClause = PClause' PTerm
declared :: PDecl -> [Name]
tldeclared :: PDecl -> [Name]
defined :: PDecl -> [Name]
updateN :: [(Name, Name)] -> Name -> Name
updateNs :: [(Name, Name)] -> PTerm -> PTerm

-- | High level language terms
data PTerm
PQuote :: Raw -> PTerm
PRef :: FC -> Name -> PTerm

-- | A name to be defined later
PInferRef :: FC -> Name -> PTerm
PPatvar :: FC -> Name -> PTerm
PLam :: Name -> PTerm -> PTerm -> PTerm
PPi :: Plicity -> Name -> PTerm -> PTerm -> PTerm
PLet :: Name -> PTerm -> PTerm -> PTerm -> PTerm

-- | Term with explicit type
PTyped :: PTerm -> PTerm -> PTerm
PApp :: FC -> PTerm -> [PArg] -> PTerm

-- | implicitly bound application
PAppBind :: FC -> PTerm -> [PArg] -> PTerm

-- | Make an application by type matching
PMatchApp :: FC -> Name -> PTerm
PCase :: FC -> PTerm -> [(PTerm, PTerm)] -> PTerm
PTrue :: FC -> PTerm
PFalse :: FC -> PTerm
PRefl :: FC -> PTerm -> PTerm
PResolveTC :: FC -> PTerm
PEq :: FC -> PTerm -> PTerm -> PTerm
PRewrite :: FC -> PTerm -> PTerm -> (Maybe PTerm) -> PTerm
PPair :: FC -> PTerm -> PTerm -> PTerm
PDPair :: FC -> PTerm -> PTerm -> PTerm -> PTerm
PAlternative :: Bool -> [PTerm] -> PTerm

-- | Irrelevant or hidden pattern
PHidden :: PTerm -> PTerm
PType :: PTerm
PGoal :: FC -> PTerm -> Name -> PTerm -> PTerm
PConstant :: Const -> PTerm
Placeholder :: PTerm
PDoBlock :: [PDo] -> PTerm
PIdiom :: FC -> PTerm -> PTerm
PReturn :: FC -> PTerm
PMetavar :: Name -> PTerm

-- | Proof script
PProof :: [PTactic] -> PTerm

-- | As PProof, but no auto solving
PTactics :: [PTactic] -> PTerm

-- | Error to report on elaboration
PElabError :: Err -> PTerm

-- | Special case for declaring when an LHS can't typecheck
PImpossible :: PTerm

-- | To mark a coerced argument, so as not to coerce twice
PCoerced :: PTerm -> PTerm

-- | dump a trace of unifications when building term
PUnifyLog :: PTerm -> PTerm

-- | never run implicit converions on the term
PNoImplicits :: PTerm -> PTerm
mapPT :: (PTerm -> PTerm) -> PTerm -> PTerm
data PTactic' t
Intro :: [Name] -> PTactic' t
Intros :: PTactic' t
Focus :: Name -> PTactic' t
Refine :: Name -> [Bool] -> PTactic' t
Rewrite :: t -> PTactic' t
Equiv :: t -> PTactic' t
MatchRefine :: Name -> PTactic' t
LetTac :: Name -> t -> PTactic' t
LetTacTy :: Name -> t -> t -> PTactic' t
Exact :: t -> PTactic' t
Compute :: PTactic' t
Trivial :: PTactic' t
ProofSearch :: (Maybe Name) -> Name -> [Name] -> PTactic' t
Solve :: PTactic' t
Attack :: PTactic' t
ProofState :: PTactic' t
ProofTerm :: PTactic' t
Undo :: PTactic' t
Try :: (PTactic' t) -> (PTactic' t) -> PTactic' t
TSeq :: (PTactic' t) -> (PTactic' t) -> PTactic' t
ApplyTactic :: t -> PTactic' t
Reflect :: t -> PTactic' t
Fill :: t -> PTactic' t
GoalType :: String -> (PTactic' t) -> PTactic' t
Qed :: PTactic' t
Abandon :: PTactic' t
type PTactic = PTactic' PTerm
data PDo' t
DoExp :: FC -> t -> PDo' t
DoBind :: FC -> Name -> t -> PDo' t
DoBindP :: FC -> t -> t -> PDo' t
DoLet :: FC -> Name -> t -> t -> PDo' t
DoLetP :: FC -> t -> t -> PDo' t
type PDo = PDo' PTerm
data PArg' t
PImp :: Int -> Bool -> Bool -> Name -> t -> String -> PArg' t
priority :: PArg' t -> Int
machine_inf :: PArg' t -> Bool
lazyarg :: PArg' t -> Bool
pname :: PArg' t -> Name
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PExp :: Int -> Bool -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PConstraint :: Int -> Bool -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
PTacImplicit :: Int -> Bool -> Name -> t -> t -> String -> PArg' t
priority :: PArg' t -> Int
lazyarg :: PArg' t -> Bool
pname :: PArg' t -> Name
getScript :: PArg' t -> t
getTm :: PArg' t -> t
pargdoc :: PArg' t -> String
pimp :: Name -> t -> Bool -> PArg' t
pexp :: t -> PArg' t
pconst :: t -> PArg' t
ptacimp :: Name -> t -> t -> PArg' t
type PArg = PArg' PTerm
data ClassInfo
CI :: Name -> [(Name, (FnOpts, PTerm))] -> [(Name, (Name, PDecl))] -> [Name] -> [Name] -> ClassInfo
instanceName :: ClassInfo -> Name
class_methods :: ClassInfo -> [(Name, (FnOpts, PTerm))]
class_defaults :: ClassInfo -> [(Name, (Name, PDecl))]
class_params :: ClassInfo -> [Name]
class_instances :: ClassInfo -> [Name]
data OptInfo
Optimise :: Bool -> Bool -> [Int] -> [Int] -> OptInfo
collapsible :: OptInfo -> Bool
isnewtype :: OptInfo -> Bool
forceable :: OptInfo -> [Int]
recursive :: OptInfo -> [Int]
data TypeInfo
TI :: [Name] -> Bool -> [Int] -> TypeInfo
con_names :: TypeInfo -> [Name]
codata :: TypeInfo -> Bool
param_pos :: TypeInfo -> [Int]
data DSL' t
DSL :: t -> t -> t -> t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> Maybe t -> DSL' t
dsl_bind :: DSL' t -> t
dsl_return :: DSL' t -> t
dsl_apply :: DSL' t -> t
dsl_pure :: DSL' t -> t
dsl_var :: DSL' t -> Maybe t
index_first :: DSL' t -> Maybe t
index_next :: DSL' t -> Maybe t
dsl_lambda :: DSL' t -> Maybe t
dsl_let :: DSL' t -> Maybe t
type DSL = DSL' PTerm
data SynContext
PatternSyntax :: SynContext
TermSyntax :: SynContext
AnySyntax :: SynContext
data Syntax
Rule :: [SSymbol] -> PTerm -> SynContext -> Syntax
data SSymbol
Keyword :: Name -> SSymbol
Symbol :: String -> SSymbol
Binding :: Name -> SSymbol
Expr :: Name -> SSymbol
SimpleExpr :: Name -> SSymbol
initDSL :: DSL' PTerm
data Using
UImplicit :: Name -> PTerm -> Using
UConstraint :: Name -> [Name] -> Using
data SyntaxInfo
Syn :: [Using] -> [(Name, PTerm)] -> [String] -> [Name] -> (Name -> Name) -> Bool -> Bool -> DSL -> SyntaxInfo
using :: SyntaxInfo -> [Using]
syn_params :: SyntaxInfo -> [(Name, PTerm)]
syn_namespace :: SyntaxInfo -> [String]
no_imp :: SyntaxInfo -> [Name]
decoration :: SyntaxInfo -> Name -> Name
inPattern :: SyntaxInfo -> Bool
implicitAllowed :: SyntaxInfo -> Bool
dsl_info :: SyntaxInfo -> DSL
defaultSyntax :: SyntaxInfo
expandNS :: SyntaxInfo -> Name -> Name
showDeclImp :: Bool -> PDecl' PTerm -> [Char]
showCImp :: Bool -> PClause -> String
showDImp :: Bool -> PData -> String
getImps :: [PArg] -> [(Name, PTerm)]
getExps :: [PArg] -> [PTerm]
getConsts :: [PArg] -> [PTerm]
getAll :: [PArg] -> [PTerm]

-- | Pretty-print a high-level Idris term
prettyImp :: Bool -> PTerm -> Doc

-- | Show Idris name
showName :: Maybe IState -> [(Name, Bool)] -> Bool -> Bool -> Name -> String

-- | Show Idris term
showImp :: Maybe IState -> Bool -> Bool -> PTerm -> String
getPArity :: PTerm -> Int
allNamesIn :: PTerm -> [Name]
namesIn :: [(Name, PTerm)] -> IState -> PTerm -> [Name]
usedNamesIn :: [Name] -> IState -> PTerm -> [Name]
instance Show LanguageExt
instance Eq LanguageExt
instance Read LanguageExt
instance Ord LanguageExt
instance Show OutputMode
instance Show SizeChange
instance Eq SizeChange
instance Show CGInfo
instance Show Codegen
instance Eq Codegen
instance Show Opt
instance Eq Opt
instance Show IOption
instance Eq IOption
instance Eq Fixity
instance Eq FixDecl
instance Show Static
instance Eq Static
instance Show FnOpt
instance Eq FnOpt
instance Functor PData'
instance Show t => Show (PTactic' t)
instance Eq t => Eq (PTactic' t)
instance Functor PTactic'
instance Eq t => Eq (PDo' t)
instance Functor PDo'
instance Show t => Show (PArg' t)
instance Eq t => Eq (PArg' t)
instance Functor PArg'
instance Eq PTerm
instance Show Plicity
instance Eq Plicity
instance Show OptInfo
instance Show TypeInfo
instance Show t => Show (DSL' t)
instance Functor DSL'
instance Show SynContext
instance Show SSymbol
instance Show Syntax
instance Show IBCWrite
instance Show Using
instance Eq Using
instance Show SyntaxInfo
instance Functor PDecl'
instance Functor PClause'
instance Show ClassInfo
instance Sized PTerm
instance Show PData
instance Show PClause
instance Show PDecl
instance Pretty PTerm
instance Show PTerm
instance Sized a => Sized (PArg' a)
instance Sized a => Sized (PDo' a)
instance Sized a => Sized (PTactic' a)
instance Ord FixDecl
instance Show FixDecl
instance Show Fixity

module Idris.AbsSyntax
getContext :: Idris Context
forCodegen :: Codegen -> [(Codegen, a)] -> [a]
getObjectFiles :: Codegen -> Idris [FilePath]
addObjectFile :: Codegen -> FilePath -> Idris ()
getLibs :: Codegen -> Idris [String]
addLib :: Codegen -> String -> Idris ()
getFlags :: Codegen -> Idris [String]
addFlag :: Codegen -> String -> Idris ()
addDyLib :: [String] -> Idris (Either DynamicLib String)
addHdr :: Codegen -> String -> Idris ()
addLangExt :: LanguageExt -> Idris ()
addTrans :: (Term, Term) -> Idris ()
totcheck :: (FC, Name) -> Idris ()
defer_totcheck :: (FC, Name) -> Idris ()
clear_totcheck :: Idris ()
setFlags :: Name -> [FnOpt] -> Idris ()
setAccessibility :: Name -> Accessibility -> Idris ()
setTotality :: Name -> Totality -> Idris ()
getTotality :: Name -> Idris Totality
getCoercionsTo :: IState -> Type -> [Name]
addToCG :: Name -> CGInfo -> Idris ()
getAllNames :: Name -> Idris [Name]
allNames :: [Name] -> Name -> Idris [Name]
addCoercion :: Name -> Idris ()
addDocStr :: Name -> String -> Idris ()
addToCalledG :: Name -> [Name] -> Idris ()
addInstance :: Bool -> Name -> Name -> Idris ()
addClass :: Name -> ClassInfo -> Idris ()
addIBC :: IBCWrite -> Idris ()
clearIBC :: Idris ()
getHdrs :: Codegen -> Idris [String]
setErrLine :: Int -> Idris ()
clearErr :: Idris ()
getSO :: Idris (Maybe String)
setSO :: Maybe String -> Idris ()
getIState :: Idris IState
putIState :: IState -> Idris ()

-- | A version of liftIO that puts errors into the exception type of the
--   Idris monad
runIO :: IO a -> Idris a
getName :: Idris Int
addInternalApp :: FilePath -> Int -> PTerm -> Idris ()
getInternalApp :: FilePath -> Int -> Idris PTerm
checkUndefined :: FC -> Name -> Idris ()
isUndefined :: FC -> Name -> Idris Bool
setContext :: Context -> Idris ()
updateContext :: (Context -> Context) -> Idris ()
addConstraints :: FC -> (Int, [UConstraint]) -> Idris ()
addDeferred :: [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()
addDeferredTyCon :: [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()
addDeferred' :: NameType -> [(Name, (Int, Maybe Name, Type, Bool))] -> Idris ()
solveDeferred :: Name -> Idris ()
ihPrintResult :: Handle -> String -> Idris ()
ihPrintError :: Handle -> String -> Idris ()
ihputStrLn :: Handle -> String -> Idris ()
iputStrLn :: String -> Idris ()
iPrintError :: String -> Idris ()
iPrintResult :: String -> Idris ()
iWarn :: FC -> String -> Idris ()
ideslavePutSExp :: SExpable a => String -> a -> Idris ()
iputGoal :: String -> Idris ()
isetPrompt :: String -> Idris ()
ihWarn :: Handle -> FC -> String -> Idris ()
setLogLevel :: Int -> Idris ()
setCmdLine :: [Opt] -> Idris ()
getCmdLine :: Idris [Opt]
getDumpDefun :: Idris (Maybe FilePath)
getDumpCases :: Idris (Maybe FilePath)
logLevel :: Idris Int
setErrContext :: Bool -> Idris ()
errContext :: Idris Bool
useREPL :: Idris Bool
setREPL :: Bool -> Idris ()
setNoBanner :: Bool -> Idris ()
getNoBanner :: Idris Bool
setQuiet :: Bool -> Idris ()
getQuiet :: Idris Bool
setCodegen :: Codegen -> Idris ()
codegen :: Idris Codegen
setOutputTy :: OutputType -> Idris ()
outputTy :: Idris OutputType
setIdeSlave :: Bool -> Idris ()
setTargetTriple :: String -> Idris ()
targetTriple :: Idris String
setTargetCPU :: String -> Idris ()
targetCPU :: Idris String
setOptLevel :: Word -> Idris ()
optLevel :: Idris Word
verbose :: Idris Bool
setVerbose :: Bool -> Idris ()
typeInType :: Idris Bool
setTypeInType :: Bool -> Idris ()
coverage :: Idris Bool
setCoverage :: Bool -> Idris ()
setIBCSubDir :: FilePath -> Idris ()
valIBCSubDir :: IState -> Idris FilePath
addImportDir :: FilePath -> Idris ()
setImportDirs :: [FilePath] -> Idris ()
allImportDirs :: Idris [FilePath]
colourise :: Idris Bool
setColourise :: Bool -> Idris ()
setOutH :: Handle -> Idris ()
impShow :: Idris Bool
setImpShow :: Bool -> Idris ()
setColour :: ColourType -> IdrisColour -> Idris ()
logLvl :: Int -> String -> Idris ()
cmdOptType :: Opt -> Idris Bool
iLOG :: String -> Idris ()
noErrors :: Idris Bool
setTypeCase :: Bool -> Idris ()
bi :: FC
inferTy :: Name
inferCon :: Name
inferDecl :: PData' PTerm
infTerm :: PTerm -> PTerm
infP :: TT Name
getInferTerm :: Term -> Term
getInferType :: Term -> Term
primNames :: [Name]
unitTy :: Name
unitCon :: Name
unitDecl :: PData' PTerm
falseTy :: Name
falseDecl :: PData' PTerm
pairTy :: Name
pairCon :: Name
pairDecl :: PData' PTerm
eqTy :: Name
eqCon :: Name
eqDecl :: PData' PTerm
sigmaTy :: Name
existsCon :: Name
piBind :: [(Name, PTerm)] -> PTerm -> PTerm
piBindp :: Plicity -> [(Name, PTerm)] -> PTerm -> PTerm
expandParams :: (Name -> Name) -> [(Name, PTerm)] -> [Name] -> [Name] -> PTerm -> PTerm
expandParamsD :: Bool -> IState -> (Name -> Name) -> [(Name, PTerm)] -> [Name] -> PDecl -> PDecl
mapsnd :: (t -> t2) -> (t1, t) -> (t1, t2)
getPriority :: IState -> PTerm -> Int
addStatics :: Name -> Term -> PTerm -> Idris ()
addUsingConstraints :: SyntaxInfo -> FC -> PTerm -> Idris PTerm
implicit :: SyntaxInfo -> Name -> PTerm -> Idris PTerm
implicit' :: SyntaxInfo -> [Name] -> Name -> PTerm -> Idris PTerm
implicitise :: SyntaxInfo -> [Name] -> IState -> PTerm -> (PTerm, [PArg])
addImplPat :: IState -> PTerm -> PTerm
addImplBound :: IState -> [Name] -> PTerm -> PTerm
addImplBoundInf :: IState -> [Name] -> [Name] -> PTerm -> PTerm
addImpl :: IState -> PTerm -> PTerm
addImpl' :: Bool -> [Name] -> [Name] -> IState -> PTerm -> PTerm
aiFn :: Bool -> Bool -> IState -> FC -> Name -> [PArg] -> Either Err PTerm
stripLinear :: IState -> PTerm -> PTerm
stripUnmatchable :: IState -> PTerm -> PTerm
mkPApp :: FC -> Int -> PTerm -> [PArg] -> PTerm
findStatics :: IState -> PTerm -> (PTerm, [Bool])
dumpDecls :: [PDecl] -> String
dumpDecl :: PDecl' PTerm -> [Char]
data EitherErr a b
LeftErr :: a -> EitherErr a b
RightOK :: b -> EitherErr a b
toEither :: EitherErr a b -> Either a b
matchClause :: IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
matchClause' :: Bool -> IState -> PTerm -> PTerm -> Either (PTerm, PTerm) [(Name, PTerm)]
substMatches :: [(Name, PTerm)] -> PTerm -> PTerm
substMatchesShadow :: [(Name, PTerm)] -> [Name] -> PTerm -> PTerm
substMatch :: Name -> PTerm -> PTerm -> PTerm
substMatchShadow :: Name -> [Name] -> PTerm -> PTerm -> PTerm
shadow :: Name -> Name -> PTerm -> PTerm
instance Monad (EitherErr a)

module Idris.Primitives
primitives :: [Prim]
data Prim
Prim :: Name -> Type -> Int -> ([Const] -> Maybe Const) -> (Int, PrimFn) -> Totality -> Prim
p_name :: Prim -> Name
p_type :: Prim -> Type
p_arity :: Prim -> Int
p_def :: Prim -> [Const] -> Maybe Const
p_lexp :: Prim -> (Int, PrimFn)
p_total :: Prim -> Totality

module Idris.Imports
data IFileType
IDR :: FilePath -> IFileType
LIDR :: FilePath -> IFileType
IBC :: FilePath -> IFileType -> IFileType
srcPath :: FilePath -> FilePath
lsrcPath :: FilePath -> FilePath
ibcPath :: FilePath -> Bool -> FilePath -> FilePath
ibcPathWithFallback :: FilePath -> FilePath -> IO FilePath
ibcPathNoFallback :: FilePath -> FilePath -> FilePath
findImport :: [FilePath] -> FilePath -> FilePath -> IO IFileType
findInPath :: [FilePath] -> FilePath -> IO FilePath
instance Show IFileType
instance Eq IFileType

module Idris.Delaborate
bugaddr :: [Char]
delab :: IState -> Term -> PTerm
delabTy :: IState -> Name -> PTerm
delab' :: IState -> Term -> Bool -> PTerm
delabTy' :: IState -> [PArg] -> Term -> Bool -> PTerm
indented :: String -> [Char]
pshow :: IState -> Err -> String
showSc :: IState -> [(Name, Term)] -> [Char]
showqual :: IState -> Name -> String
showbasic :: Name -> String

module Idris.Error
iucheck :: Idris ()
showErr :: Err -> Idris String
report :: IOError -> String
idrisCatch :: Idris a -> (Err -> Idris a) -> Idris a
setAndReport :: Err -> Idris ()
ifail :: String -> Idris a
ierror :: Err -> Idris a
tclift :: TC a -> Idris a
tctry :: TC a -> TC a -> Idris a
getErrLine :: Err -> Int
getErrColumn :: Err -> Int

module Idris.IBC
ibcVersion :: Word8
data IBCFile
IBCFile :: Word8 -> FilePath -> [FilePath] -> [(Name, [PArg])] -> [FixDecl] -> [(Name, [Bool])] -> [(Name, ClassInfo)] -> [(Bool, Name, Name)] -> [(Name, DSL)] -> [(Name, TypeInfo)] -> [(Name, OptInfo)] -> [Syntax] -> [String] -> [(Codegen, FilePath)] -> [(Codegen, String)] -> [(Codegen, String)] -> [String] -> [(Codegen, String)] -> [(Name, Accessibility)] -> [(Name, Totality)] -> [(Name, [FnOpt])] -> [(Name, CGInfo)] -> [(Name, Def)] -> [(Name, String)] -> [(Term, Term)] -> [Name] -> [(FilePath, Int, PTerm)] -> IBCFile
ver :: IBCFile -> Word8
sourcefile :: IBCFile -> FilePath
ibc_imports :: IBCFile -> [FilePath]
ibc_implicits :: IBCFile -> [(Name, [PArg])]
ibc_fixes :: IBCFile -> [FixDecl]
ibc_statics :: IBCFile -> [(Name, [Bool])]
ibc_classes :: IBCFile -> [(Name, ClassInfo)]
ibc_instances :: IBCFile -> [(Bool, Name, Name)]
ibc_dsls :: IBCFile -> [(Name, DSL)]
ibc_datatypes :: IBCFile -> [(Name, TypeInfo)]
ibc_optimise :: IBCFile -> [(Name, OptInfo)]
ibc_syntax :: IBCFile -> [Syntax]
ibc_keywords :: IBCFile -> [String]
ibc_objs :: IBCFile -> [(Codegen, FilePath)]
ibc_libs :: IBCFile -> [(Codegen, String)]
ibc_cgflags :: IBCFile -> [(Codegen, String)]
ibc_dynamic_libs :: IBCFile -> [String]
ibc_hdrs :: IBCFile -> [(Codegen, String)]
ibc_access :: IBCFile -> [(Name, Accessibility)]
ibc_total :: IBCFile -> [(Name, Totality)]
ibc_flags :: IBCFile -> [(Name, [FnOpt])]
ibc_cg :: IBCFile -> [(Name, CGInfo)]
ibc_defs :: IBCFile -> [(Name, Def)]
ibc_docstrings :: IBCFile -> [(Name, String)]
ibc_transforms :: IBCFile -> [(Term, Term)]
ibc_coercions :: IBCFile -> [Name]
ibc_lineapps :: IBCFile -> [(FilePath, Int, PTerm)]
initIBC :: IBCFile
loadIBC :: FilePath -> Idris ()
writeIBC :: FilePath -> FilePath -> Idris ()
mkIBC :: [IBCWrite] -> IBCFile -> Idris IBCFile
ibc :: IState -> IBCWrite -> IBCFile -> Idris IBCFile
process :: IBCFile -> FilePath -> Idris ()
timestampOlder :: FilePath -> FilePath -> IO ()
pImports :: [FilePath] -> Idris ()
pImps :: [(Name, [PArg])] -> Idris ()
pFixes :: [FixDecl] -> Idris ()
pStatics :: [(Name, [Bool])] -> Idris ()
pClasses :: [(Name, ClassInfo)] -> Idris ()
pInstances :: [(Bool, Name, Name)] -> Idris ()
pDSLs :: [(Name, DSL)] -> Idris ()
pDatatypes :: [(Name, TypeInfo)] -> Idris ()
pOptimise :: [(Name, OptInfo)] -> Idris ()
pSyntax :: [Syntax] -> Idris ()
pKeywords :: [String] -> Idris ()
pObjs :: [(Codegen, FilePath)] -> Idris ()
pLibs :: [(Codegen, String)] -> Idris ()
pCGFlags :: [(Codegen, String)] -> Idris ()
pDyLibs :: [String] -> Idris ()
pHdrs :: [(Codegen, String)] -> Idris ()
pDefs :: [(Name, Def)] -> Idris ()
pDocs :: [(Name, String)] -> Idris ()
pAccess :: [(Name, Accessibility)] -> Idris ()
pFlags :: [(Name, [FnOpt])] -> Idris ()
pTotal :: [(Name, Totality)] -> Idris ()
pCG :: [(Name, CGInfo)] -> Idris ()
pCoercions :: [Name] -> Idris ()
pTrans :: [(Term, Term)] -> Idris ()
pLineApps :: [(FilePath, Int, PTerm)] -> Idris ()
instance Show IBCFile
instance Binary Codegen
instance Binary SSymbol
instance Binary t => Binary (DSL' t)
instance Binary Syntax
instance Binary SynContext
instance Binary TypeInfo
instance Binary OptInfo
instance Binary ClassInfo
instance Binary t => Binary (PArg' t)
instance Binary t => Binary (PDo' t)
instance Binary t => Binary (PTactic' t)
instance Binary PTerm
instance Binary t => Binary (PData' t)
instance Binary t => Binary (PClause' t)
instance Binary SyntaxInfo
instance Binary Using
instance Binary t => Binary (PDecl' t)
instance Binary Plicity
instance Binary Static
instance Binary FixDecl
instance Binary Fixity
instance Binary FnOpt
instance Binary IBCFile
instance Binary Totality
instance Binary PReason
instance Binary Accessibility
instance Binary Def
instance Binary CaseInfo
instance Binary CaseDefs
instance Binary CaseAlt
instance Binary SC
instance Binary (TT Name)
instance Binary NameType
instance Binary b => Binary (Binder b)
instance Binary Raw
instance Binary Const
instance Binary SpecialName
instance Binary Name
instance Binary FC
instance Binary CGInfo
instance Binary SizeChange

module Idris.ParseHelpers

-- | Idris parser with state used during parsing
type IdrisParser = StateT IState IdrisInnerParser
newtype IdrisInnerParser a
IdrisInnerParser :: Parser a -> IdrisInnerParser a
runInnerParser :: IdrisInnerParser a -> Parser a

-- | Generalized monadic parsing constraint type
type MonadicParsing m = (DeltaParsing m, LookAheadParsing m, TokenParsing m, Monad m)

-- | Helper to run Idris inner parser based stateT parsers
runparser :: StateT st IdrisInnerParser res -> st -> String -> String -> Result res

-- | Consumes any simple whitespace (any character which satisfies
--   Char.isSpace)
simpleWhiteSpace :: MonadicParsing m => m ()

-- | Checks if a charcter is end of line
isEol :: Char -> Bool
eol :: MonadicParsing m => m ()

-- | Checks if a character is a documentation comment marker
isDocCommentMarker :: Char -> Bool

-- | Consumes a single-line comment SingleLineComment_t ::= '--' EOL_t |
--   '--' ~DocCommentMarker_t ~EOL_t* EOL_t ;
singleLineComment :: MonadicParsing m => m ()

-- | Consumes a multi-line comment MultiLineComment_t ::= '{ -- }' | '{ -'
--   ~DocCommentMarker_t InCommentChars_t ;
--   
--   InCommentChars_t ::= '- }' | MultiLineComment_t InCommentChars_t | ~'-
--   }'+ InCommentChars_t ;
multiLineComment :: MonadicParsing m => m ()

-- | Parses a documentation comment (similar to haddoc) given a marker
--   character DocComment_t ::= '--' DocCommentMarker_t ~EOL_t* EOL_t | '{
--   -' DocCommentMarket_t ~'- }'* '- }' ;
docComment :: MonadicParsing m => Char -> m String

-- | Parses some white space
whiteSpace :: MonadicParsing m => m ()

-- | Parses a string literal
stringLiteral :: MonadicParsing m => m String

-- | Parses a char literal
charLiteral :: MonadicParsing m => m Char

-- | Parses a natural number
natural :: MonadicParsing m => m Integer

-- | Parses an integral number
integer :: MonadicParsing m => m Integer

-- | Parses a floating point number
float :: MonadicParsing m => m Double

-- | Idris Style for parsing identifiers/reserved keywords
idrisStyle :: MonadicParsing m => IdentifierStyle m
char :: MonadicParsing m => Char -> m Char
string :: MonadicParsing m => String -> m String

-- | Parses a character as a token
lchar :: MonadicParsing m => Char -> m Char

-- | Parses string as a token
symbol :: MonadicParsing m => String -> m String

-- | Parses a reserved identifier
reserved :: MonadicParsing m => String -> m ()

-- | Parses a reserved operator
reservedOp :: MonadicParsing m => String -> m ()
identifier :: MonadicParsing m => m String

-- | Parses an identifier with possible namespace as a name
iName :: MonadicParsing m => [String] -> m Name

-- | Parses an string possibly prefixed by a namespace
maybeWithNS :: MonadicParsing m => m String -> Bool -> [String] -> m Name

-- | Parses a name
name :: IdrisParser Name

-- | List of all initial segments in ascending order of a list. Every such
--   initial segment ends right before an element satisfying the given
--   condition.
initsEndAt :: (a -> Bool) -> [a] -> [[a]]

-- | Create a <a>Name</a> from a pair of strings representing a base name
--   and its namespace.
mkName :: (String, String) -> Name
opChars :: String
operatorLetter :: MonadicParsing m => m Char

-- | Parses an operator
operator :: MonadicParsing m => m String

-- | Get filename from position (returns <a>(interactive)</a> when no
--   source file is given)
fileName :: Delta -> String

-- | Get line number from position
lineNum :: Delta -> Int

-- | Get column number from position
columnNum :: Delta -> Int

-- | Get file position as FC
getFC :: MonadicParsing m => m FC

-- | Bind constraints to term
bindList :: (Name -> PTerm -> PTerm -> PTerm) -> [(Name, PTerm)] -> PTerm -> PTerm

-- | Push indentation to stack
pushIndent :: IdrisParser ()

-- | Pops indentation from stack
popIndent :: IdrisParser ()

-- | Gets current indentation
indent :: IdrisParser Int

-- | Gets last indentation
lastIndent :: IdrisParser Int
indented :: IdrisParser a -> IdrisParser a

-- | Applies parser to get a block (which has possibly indented statements)
indentedBlock :: IdrisParser a -> IdrisParser [a]

-- | Applies parser to get a block with at least one statement (which has
--   possibly indented statements)
indentedBlock1 :: IdrisParser a -> IdrisParser [a]
indentedBlockS :: IdrisParser a -> IdrisParser a

-- | Checks if the following character matches provided parser
lookAheadMatches :: MonadicParsing m => m a -> m Bool

-- | Parses a start of block
openBlock :: IdrisParser ()

-- | Parses an end of block
closeBlock :: IdrisParser ()

-- | Parses a terminator
terminator :: IdrisParser ()

-- | Parses and keeps a terminator
keepTerminator :: IdrisParser ()

-- | Checks if application expression does not end
notEndApp :: IdrisParser ()

-- | Checks that it is not end of block
notEndBlock :: IdrisParser ()

-- | Representation of an operation that can compare the current
--   indentation with the last indentation, and an error message if it
--   fails
data IndentProperty
IndentProperty :: (Int -> Int -> Bool) -> String -> IndentProperty

-- | Allows comparison of indent, and fails if property doesn't hold
indentPropHolds :: IndentProperty -> IdrisParser ()

-- | Greater-than indent property
gtProp :: IndentProperty

-- | Greater-than or equal to indent property
gteProp :: IndentProperty

-- | Equal indent property
eqProp :: IndentProperty

-- | Less-than indent property
ltProp :: IndentProperty

-- | Less-than or equal to indent property
lteProp :: IndentProperty

-- | Checks that there are no braces that are not closed
notOpenBraces :: IdrisParser ()

-- | Parses an accessibilty modifier (e.g. public, private)
accessibility :: IdrisParser Accessibility
addAcc :: Name -> Maybe Accessibility -> IdrisParser ()

-- | Add accessbility option for data declarations (works for classes too -
--   <tt>abstract</tt> means the data/class is visible but members not)
accData :: Maybe Accessibility -> Name -> [Name] -> IdrisParser ()

-- | Error message with possible fixes list
fixErrorMsg :: String -> [String] -> String

-- | Collect <a>PClauses</a> with the same function name
collect :: [PDecl] -> [PDecl]
instance Monad IdrisInnerParser
instance Functor IdrisInnerParser
instance MonadPlus IdrisInnerParser
instance Applicative IdrisInnerParser
instance Alternative IdrisInnerParser
instance CharParsing IdrisInnerParser
instance LookAheadParsing IdrisInnerParser
instance Parsing IdrisInnerParser
instance DeltaParsing IdrisInnerParser
instance MarkParsing Delta IdrisInnerParser
instance Monoid (IdrisInnerParser a)
instance TokenParsing IdrisInnerParser

module Idris.Coverage
mkPatTm :: PTerm -> Idris Term
genClauses :: FC -> Name -> [Term] -> [PClause] -> Idris [PTerm]
fnub :: [PTerm] -> [PTerm]
fnub' :: [PTerm] -> [PTerm] -> [PTerm]
quickEq :: PTerm -> PTerm -> Bool
qelem :: PTerm -> [PTerm] -> Bool
genAll :: IState -> [PTerm] -> [PTerm]
upd :: t -> PArg' t -> PArg' t
checkPositive :: Name -> (Name, Type) -> Idris ()
calcProd :: IState -> FC -> Name -> [([Name], Term, Term)] -> Idris Totality
calcTotality :: [Name] -> FC -> Name -> [([Name], Term, Term)] -> Idris Totality
checkTotality :: [Name] -> FC -> Name -> Idris Totality
checkDeclTotality :: (FC, Name) -> Idris Totality
buildSCG :: (FC, Name) -> Idris ()
buildSCG' :: IState -> [(Term, Term)] -> [Name] -> [SCGEntry]
checkSizeChange :: Name -> Idris Totality
type MultiPath = [SCGEntry]
mkMultiPaths :: IState -> MultiPath -> [SCGEntry] -> [MultiPath]
checkMP :: IState -> Int -> MultiPath -> Totality
allNothing :: [Maybe t] -> Bool
collapseNothing :: [(Maybe t1, t)] -> [(Maybe t1, t)]
noPartial :: [Totality] -> Totality
collapse :: [Totality] -> Totality
collapse' :: Totality -> [Totality] -> Totality

module Idris.DSL
debindApp :: SyntaxInfo -> PTerm -> PTerm
desugar :: SyntaxInfo -> IState -> PTerm -> PTerm
expandDo :: DSL -> PTerm -> PTerm
var :: DSL -> Name -> PTerm -> Int -> PTerm
unIdiom :: PTerm -> PTerm -> FC -> PTerm -> PTerm
debind :: PTerm -> PTerm -> PTerm

module Idris.DataOpts
forceArgs :: Name -> Type -> Idris ()
collapseCons :: Name -> [(Name, Type)] -> Idris ()
class Optimisable term
applyOpts :: Optimisable term => term -> Idris term
stripCollapsed :: Optimisable term => term -> Idris term
applyDataOpt :: OptInfo -> Name -> [Raw] -> Raw
applyDataOptRT :: OptInfo -> Name -> Int -> Int -> [Term] -> Term
instance Optimisable (TT Name)
instance Optimisable t => Optimisable (Binder t)
instance Optimisable Raw
instance Optimisable a => Optimisable (Either a (a, a))
instance Optimisable a => Optimisable [a]
instance (Optimisable a, Optimisable b) => Optimisable (vs, a, b)
instance (Optimisable a, Optimisable b) => Optimisable (a, b)

module Idris.DeepSeq
instance NFData SyntaxInfo
instance NFData Using
instance NFData SSymbol
instance NFData Syntax
instance NFData SynContext
instance NFData t => NFData (DSL' t)
instance NFData TypeInfo
instance NFData OptInfo
instance NFData ClassInfo
instance NFData t => NFData (PArg' t)
instance NFData t => NFData (PDo' t)
instance NFData t => NFData (PTactic' t)
instance NFData PTerm
instance NFData t => NFData (PData' t)
instance NFData t => NFData (PClause' t)
instance NFData t => NFData (PDecl' t)
instance NFData FnOpt
instance NFData Plicity
instance NFData Static
instance NFData FixDecl
instance NFData Fixity
instance NFData CGInfo
instance NFData SizeChange
instance NFData n => NFData (TT n)
instance NFData NameType
instance NFData UExp
instance NFData b => NFData (Binder b)
instance NFData Err
instance NFData ArithTy
instance NFData NativeTy
instance NFData IntTy
instance NFData SpecialName
instance NFData Name
instance NFData FC
instance NFData Raw

module Idris.Inliner
inlineDef :: IState -> [([Name], Term, Term)] -> [([Name], Term, Term)]
inlineTerm :: IState -> Term -> Term

module Idris.PartialEval
partial_eval :: Context -> [(Name, Maybe Int)] -> [Either Term (Term, Term)] -> [Either Term (Term, Term)]
getSpecApps :: IState -> [Name] -> Term -> [(Name, [(PEArgType, Term)])]
specType :: [(PEArgType, Term)] -> Type -> (Type, [(PEArgType, Term)])
mkPE_TyDecl :: IState -> [(PEArgType, Term)] -> Type -> PTerm
mkPE_TermDecl :: IState -> Name -> Name -> [(PEArgType, Term)] -> [(PTerm, PTerm)]
data PEArgType
ImplicitS :: PEArgType
ImplicitD :: PEArgType
ExplicitS :: PEArgType
ExplicitD :: PEArgType
UnifiedD :: PEArgType
instance Eq PEArgType
instance Show PEArgType

module Idris.ProofSearch
trivial :: (PTerm -> ElabD ()) -> IState -> ElabD ()
proofSearch :: (PTerm -> ElabD ()) -> Maybe Name -> Name -> [Name] -> IState -> ElabD ()

module Idris.ElabTerm
data ElabInfo
EInfo :: [(Name, PTerm)] -> Ctxt [Name] -> (Name -> Name) -> Maybe [String] -> ElabInfo
params :: ElabInfo -> [(Name, PTerm)]
inblock :: ElabInfo -> Ctxt [Name]
liftname :: ElabInfo -> Name -> Name
namespace :: ElabInfo -> Maybe [String]
toplevel :: ElabInfo
build :: IState -> ElabInfo -> Bool -> Name -> PTerm -> ElabD (Term, [(Name, (Int, Maybe Name, Type))], [PDecl])
buildTC :: IState -> ElabInfo -> Bool -> Bool -> Name -> PTerm -> ElabD (Term, [(Name, (Int, Maybe Name, Type))], [PDecl])
elab :: IState -> ElabInfo -> Bool -> Bool -> Name -> PTerm -> ElabD ()
pruneAlt :: [PTerm] -> [PTerm]
pruneByType :: Term -> Context -> [PTerm] -> [PTerm]
findInstances :: IState -> Term -> [Name]
trivial' :: IState -> ElabD ()
proofSearch' :: IState -> Maybe Name -> Name -> [Name] -> ElabD ()
resolveTC :: Int -> Name -> IState -> ElabD ()
collectDeferred :: Maybe Name -> Term -> State [(Name, (Int, Maybe Name, Type))] Term
runTac :: Bool -> IState -> PTactic -> ElabD ()

-- | Prefix a name with the <a>Reflection.Language</a> namespace
reflm :: String -> Name

-- | Reify tactics from their reflected representation
reify :: IState -> Term -> ElabD PTactic
reifyApp :: IState -> Name -> [Term] -> ElabD PTactic

-- | Reify terms from their reflected representation
reifyTT :: Term -> ElabD Term
reifyTTApp :: Name -> [Term] -> ElabD Term

-- | Reify raw terms from their reflected representation
reifyRaw :: Term -> ElabD Raw
reifyRawApp :: Name -> [Term] -> ElabD Raw
reifyTTName :: Term -> ElabD Name
reifyTTNameApp :: Name -> [Term] -> ElabD Name
reifyTTNamespace :: Term -> ElabD [String]
reifyTTNameType :: Term -> ElabD NameType
reifyTTBinder :: (Term -> ElabD a) -> Name -> Term -> ElabD (Binder a)
reifyTTBinderApp :: (Term -> ElabD a) -> Name -> [Term] -> ElabD (Binder a)
reifyTTConst :: Term -> ElabD Const
reifyTTConstApp :: Name -> Term -> ElabD Const
reifyTTUExp :: Term -> ElabD UExp

-- | Create a reflected call to a named function/constructor
reflCall :: String -> [Raw] -> Raw

-- | Lift a term into its Language.Reflection.TT representation
reflect :: Term -> Raw
reflectNameType :: NameType -> Raw
reflectName :: Name -> Raw
reflectBinder :: Binder Term -> Raw
reflectConstant :: Const -> Raw
reflectUExp :: UExp -> Raw

-- | Reflect the environment of a proof into a List (TTName, Binder TT)
reflectEnv :: Env -> Raw

-- | Reflect an error into the internal datatype of Idris -- TODO
reflectErr :: Err -> Raw
envTupleType :: Raw
solveAll :: Elab' aux ()
mkSpecialised :: IState -> FC -> Name -> [PTerm] -> PTerm -> ElabD PTerm
mkSpecDecl :: IState -> Name -> [(PTerm, Bool)] -> PTerm -> ElabD PTerm

module Idris.ParseOps

-- | Creates table for fixity declarations to build expression parser using
--   pre-build and user-defined operator/fixity declarations
table :: [FixDecl] -> OperatorTable IdrisParser PTerm

-- | Calculates table for fixtiy declarations
toTable :: [FixDecl] -> OperatorTable IdrisParser PTerm

-- | Binary operator
binary :: String -> (FC -> PTerm -> PTerm -> PTerm) -> Assoc -> Operator IdrisParser PTerm

-- | Prefix operator
prefix :: String -> (FC -> PTerm -> PTerm) -> Operator IdrisParser PTerm

-- | Backtick operator
backtick :: Operator IdrisParser PTerm

-- | Parses an operator in function position i.e. enclosed by `()', with an
--   optional namespace
--   
--   <pre>
--   OperatorFront ::= (Identifier_t <a>.</a>)? '(' Operator_t ')';
--   </pre>
operatorFront :: IdrisParser Name

-- | Parses a function (either normal name or operator)
--   
--   <pre>
--   FnName ::= Name | OperatorFront;
--   </pre>
fnName :: IdrisParser Name

-- | Parses a fixity declaration <tt> Fixity ::= FixityType Natural_t
--   OperatorList Terminator ; </tt>
fixity :: IdrisParser PDecl

-- | Parses a fixity declaration type (i.e. infix or prefix, associtavity)
--   <tt> FixityType ::= 'infixl' | 'infixr' | 'infix' | <a>prefix</a> ;
--   </tt>
fixityType :: IdrisParser (Int -> Fixity)

module Idris.ParseExpr

-- | Allow implicit type declarations
allowImp :: SyntaxInfo -> SyntaxInfo

-- | Disallow implicit type declarations
disallowImp :: SyntaxInfo -> SyntaxInfo

-- | Parses an expression as a whole <tt> FullExpr ::= Expr EOF_t; </tt>
fullExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an expression <tt> Expr ::= Expr'; </tt>
expr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses either an internally defined expression or a user-defined one
--   <tt> Expr' ::= <a>External (User-defined) Syntax</a> | InternalExpr;
--   </tt>
expr' :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a user-defined expression
externalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a simple user-defined expression
simpleExternalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Tries to parse a user-defined expression given a list of syntactic
--   extensions
extensions :: SyntaxInfo -> [Syntax] -> IdrisParser PTerm
data SynMatch
SynTm :: PTerm -> SynMatch
SynBind :: Name -> SynMatch

-- | Tries to parse an expression given a user-defined rule
extension :: SyntaxInfo -> Syntax -> IdrisParser PTerm

-- | Parses a (normal) built-in expression <tt> InternalExpr ::= App |
--   MatchApp | UnifyLog | RecordType | SimpleExpr | Lambda | QuoteGoal |
--   Let | RewriteTerm | Pi | DoBlock ; </tt>
internalExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a case expression <tt> CaseExpr ::= 'case' Expr 'of' OpenBlock
--   CaseOption+ CloseBlock; </tt>
caseExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a case in a case expression <tt> CaseOption ::= Expr '=&gt;'
--   Expr Terminator ; </tt>
caseOption :: SyntaxInfo -> IdrisParser (PTerm, PTerm)

-- | Parses a proof block <tt> ProofExpr ::= <tt>proof</tt> OpenBlock
--   Tactic'* CloseBlock ; </tt>
proofExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a tactics block <tt> TacticsExpr := <tt>tactics</tt> OpenBlock
--   Tactic'* CloseBlock ; </tt>
tacticsExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a simple expression <tt> SimpleExpr ::= '![' Term ']' |
--   <tt>?</tt> Name | % 'instance' | <tt>refl</tt> ('{' Expr '}')? |
--   ProofExpr | TacticsExpr | CaseExpr | FnName | List | Comprehension |
--   Alt | Idiom | '(' Bracketed | Constant | Type | '_|_' | '_' | ; </tt>
simpleExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses the rest of an expression in braces <tt> Bracketed ::= ')' |
--   Expr ')' | ExprList ')' | Expr <a>**</a> Expr ')' | Operator Expr ')'
--   | Expr Operator ')' | Name <tt>:</tt> Expr <a>**</a> Expr ')' ; </tt>
bracketed :: SyntaxInfo -> IdrisParser PTerm

-- | Finds optimal type for integer constant
modifyConst :: SyntaxInfo -> FC -> PTerm -> PTerm

-- | Parses a list literal expression e.g. [1,2,3] <tt> ListExpr ::= '['
--   ExprList? ']' ; </tt> <tt> ExprList ::= Expr | Expr ',' ExprList ;
--   </tt>
listExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an alternative expression <tt> Alt ::= '(|' Expr_List '|)';
--   Expr_List ::= Expr' | Expr' ',' Expr_List ; </tt>
alt :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a possibly hidden simple expression <tt> HSimpleExpr ::=
--   <a>.</a> SimpleExpr | SimpleExpr ; </tt>
hsimpleExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a matching application expression <tt> MatchApp ::= SimpleExpr
--   <tt>&lt;==</tt> FnName ; </tt>
matchApp :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a unification log expression UnifyLog ::= <tt>%</tt>
--   <a>unifyLog</a> SimpleExpr ;
unifyLog :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a no implicits expression <tt> NoImplicits ::= <tt>%</tt>
--   <a>noImplicits</a> SimpleExpr ; </tt>
noImplicits :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a function application expression <tt> App ::=
--   <tt>mkForeign</tt> Arg Arg* | SimpleExpr Arg+ ; </tt>
app :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a function argument <tt> Arg ::= ImplicitArg | ConstraintArg |
--   SimpleExpr ; </tt>
arg :: SyntaxInfo -> IdrisParser PArg

-- | Parses an implicit function argument <tt> ImplicitArg ::= '{' Name
--   ('=' Expr)? '}' ; </tt>
implicitArg :: SyntaxInfo -> IdrisParser PArg

-- | Parses a constraint argument (for selecting a named type class
--   instance)
--   
--   <pre>
--   ConstraintArg ::=
--     '@{' Expr '}'
--     ;
--   </pre>
constraintArg :: SyntaxInfo -> IdrisParser PArg

-- | Parses a record field setter expression <tt> RecordType ::=
--   <tt>record</tt> '{' FieldTypeList '}'; </tt> <tt> FieldTypeList ::=
--   FieldType | FieldType ',' FieldTypeList ; </tt> <tt> FieldType ::=
--   FnName '=' Expr ; </tt>
recordType :: SyntaxInfo -> IdrisParser PTerm

-- | Creates setters for record types on necessary functions
mkType :: Name -> Name

-- | Parses a type signature <tt> TypeSig ::= <tt>:</tt> Expr ; </tt> <tt>
--   TypeExpr ::= ConstraintList? Expr; </tt>
typeExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a lambda expression <tt> Lambda ::= <a>\\</a> TypeOptDeclList
--   '=&gt;' Expr | <a>\\</a> SimpleExprList '=&gt;' Expr ; </tt> <tt>
--   SimpleExprList ::= SimpleExpr | SimpleExpr ',' SimpleExprList ; </tt>
lambda :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a term rewrite expression <tt> RewriteTerm ::= <tt>rewrite</tt>
--   Expr (<tt>==&gt;</tt> Expr)? 'in' Expr ; </tt>
rewriteTerm :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a let binding <tt> Let ::= 'let' Name TypeSig'? '=' Expr 'in'
--   Expr | 'let' Expr' '=' Expr' 'in' Expr TypeSig' ::= <tt>:</tt> Expr' ;
--   </tt>
let_ :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a quote goal
--   
--   <pre>
--   QuoteGoal ::=
--     <a>quoteGoal</a> Name <tt>by</tt> Expr 'in' Expr
--     ;
--   </pre>
quoteGoal :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a dependent type signature <tt> Pi ::= '|'? Static? '('
--   TypeDeclList ')' DocComment '-&gt;' Expr | '|'? Static? '{'
--   TypeDeclList '}' '-&gt;' Expr | '{' <tt>auto</tt> TypeDeclList '}'
--   '-&gt;' Expr | '{' 'default' TypeDeclList '}' '-&gt;' Expr ; </tt>
pi :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a type constraint list
--   
--   <pre>
--   ConstraintList ::=
--       '(' Expr_List ')' '=&gt;'
--     | Expr              '=&gt;'
--     ;
--   </pre>
constraintList :: SyntaxInfo -> IdrisParser [PTerm]

-- | Parses a type declaration list <tt> TypeDeclList ::=
--   FunctionSignatureList | NameList TypeSig ; </tt>
--   
--   <pre>
--   FunctionSignatureList ::=
--       Name TypeSig
--     | Name TypeSig ',' FunctionSignatureList
--     ;
--   </pre>
typeDeclList :: SyntaxInfo -> IdrisParser [(Name, PTerm)]

-- | Parses a type declaration list with optional parameters <tt>
--   TypeOptDeclList ::= NameOrPlaceholder TypeSig? | NameOrPlaceholder
--   TypeSig? ',' TypeOptDeclList ; </tt>
--   
--   <pre>
--   NameOrPlaceHolder ::= Name | '_';
--   </pre>
tyOptDeclList :: SyntaxInfo -> IdrisParser [(Name, PTerm)]

-- | Parses a list comprehension <tt> Comprehension ::= '[' Expr '|' DoList
--   ']'; </tt>
--   
--   <pre>
--   DoList ::=
--       Do
--     | Do ',' DoList
--     ;
--   </pre>
comprehension :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a do-block <tt> Do' ::= Do KeepTerminator; </tt>
--   
--   <pre>
--   DoBlock ::=
--     'do' OpenBlock Do'+ CloseBlock
--     ;
--   </pre>
doBlock :: SyntaxInfo -> IdrisParser PTerm

-- | Parses an expression inside a do block <tt> Do ::= 'let' Name
--   TypeSig'? '=' Expr | 'let' Expr' '=' Expr | Name '&lt;-' Expr | Expr'
--   '&lt;-' Expr | Expr ; </tt>
do_ :: SyntaxInfo -> IdrisParser PDo

-- | Parses an expression in idiom brackets <tt> Idiom ::= '[|' Expr '|]';
--   </tt>
idiom :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a constant or literal expression
--   
--   <pre>
--   Constant ::=
--       <a>Integer</a>
--     | <a>Int</a>
--     | <a>Char</a>
--     | <a>Float</a>
--     | <a>String</a>
--     | <tt>Ptr</tt>
--     | <tt>Bits8</tt>
--     | <tt>Bits16</tt>
--     | <tt>Bits32</tt>
--     | <tt>Bits64</tt>
--     | <tt>Bits8x16</tt>
--     | <tt>Bits16x8</tt>
--     | <tt>Bits32x4</tt>
--     | <tt>Bits64x2</tt>
--     | Float_t
--     | Natural_t
--     | String_t
--     | Char_t
--     ;
--   </pre>
constant :: IdrisParser Const

-- | Parses a static modifier
--   
--   <pre>
--   Static ::=
--     '[' static ']'
--   ;
--   </pre>
static :: IdrisParser Static

-- | Parses a tactic script
--   
--   <pre>
--   Tactic ::= <tt>intro</tt> NameList?
--          |   <tt>intros</tt>
--          |   <tt>refine</tt>      Name Imp+
--          |   <tt>mrefine</tt>     Name
--          |   <tt>rewrite</tt>     Expr
--          |   <tt>equiv</tt>       Expr
--          |   'let'         Name <tt>:</tt> Expr' '=' Expr
--          |   'let'         Name           '=' Expr
--          |   <tt>focus</tt>       Name
--          |   <tt>exact</tt>       Expr
--          |   <tt>applyTactic</tt> Expr
--          |   <tt>reflect</tt>     Expr
--          |   <tt>fill</tt>        Expr
--          |   <a>try</a>         Tactic '|' Tactic
--          |   '{' TacticSeq '}'
--          |   <tt>compute</tt>
--          |   <tt>trivial</tt>
--          |   <tt>solve</tt>
--          |   <tt>attack</tt>
--          |   <a>state</a>
--          |   <tt>term</tt>
--          |   <tt>undo</tt>
--          |   <tt>qed</tt>
--          |   <tt>abandon</tt>
--          |   <tt>:</tt> <tt>q</tt>
--          ;
--   
--   Imp ::= <tt>?</tt> | '_';
--   
--   TacticSeq ::=
--       Tactic ';' Tactic
--     | Tactic ';' TacticSeq
--     ;
--   </pre>
tactic :: SyntaxInfo -> IdrisParser PTactic

-- | Parses a tactic as a whole
fullTactic :: SyntaxInfo -> IdrisParser PTactic

module Idris.ParseData

-- | Parses a record type declaration Record ::= DocComment Accessibility?
--   <a>record</a> FnName TypeSig 'where' OpenBlock Constructor
--   KeepTerminator CloseBlock;
record :: SyntaxInfo -> IdrisParser PDecl

-- | Parses data declaration type (normal or codata) DataI ::= 'data' |
--   <a>codata</a>;
dataI :: IdrisParser Bool

-- | Parses a data type declaration Data ::= DocComment? Accessibility?
--   DataI FnName TypeSig ExplicitTypeDataRest? | DocComment?
--   Accessibility? DataI FnName Name* DataRest? ; Constructor' ::=
--   Constructor KeepTerminator; ExplicitTypeDataRest ::= 'where' OpenBlock
--   Constructor'* CloseBlock;
--   
--   DataRest ::= '=' SimpleConstructorList Terminator | 'where'! ;
--   SimpleConstructorList ::= SimpleConstructor | SimpleConstructor '|'
--   SimpleConstructorList ;
data_ :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a type constructor declaration Constructor ::= DocComment?
--   FnName TypeSig;
constructor :: SyntaxInfo -> IdrisParser (String, Name, PTerm, FC)

-- | Parses a constructor for simple discriminative union data types
--   SimpleConstructor ::= FnName SimpleExpr* DocComment?
simpleConstructor :: SyntaxInfo -> IdrisParser (String, Name, [PTerm], FC)
dsl :: SyntaxInfo -> IdrisParser PDecl

-- | Checks DSL for errors
checkDSL :: DSL -> IdrisParser ()

-- | Parses a DSL overload declaration OverloadIdentifier ::= 'let' |
--   Identifier; Overload ::= OverloadIdentifier '=' Expr;
overload :: SyntaxInfo -> IdrisParser (String, PTerm)

module Idris.UnusedArgs
findUnusedArgs :: [Name] -> Idris ()
traceUnused :: Name -> Idris ()
used :: [(Name, Int)] -> Name -> Int -> Idris Bool
getFargpos :: [(Name, [[Name]])] -> (Name, Int) -> [(Name, Int, (Name, Int))]

module Idris.Transforms
data TTOpt
TermTrans :: (TT Name -> TT Name) -> TTOpt
CaseTrans :: (SC -> SC) -> TTOpt
class Transform a
transform :: Transform a => TTOpt -> a -> a
natTrans :: [TTOpt]
zname :: Name
sname :: Name
zero :: TT Name -> TT Name
suc :: TT Name -> TT Name
natcase :: SC -> SC
instance Transform CaseAlt
instance Transform SC
instance Transform a => Transform (Binder a)
instance Transform (TT Name)

module Core.Execute
execute :: Term -> Idris Term


-- | Support for command-line completion at the REPL and in the prover
module Idris.Completion

-- | Complete REPL commands and defined identifiers
replCompletion :: CompletionFunc Idris

-- | Complete tactics and their arguments
proverCompletion :: [String] -> CompletionFunc Idris

module Idris.Docs
data FunDoc
Doc :: Name -> String -> [(Name, PArg)] -> PTerm -> (Maybe Fixity) -> FunDoc
data Doc
FunDoc :: FunDoc -> Doc
DataDoc :: FunDoc -> [FunDoc] -> Doc
ClassDoc :: Name -> String -> [FunDoc] -> Doc
showDoc :: [Char] -> [Char]
getDocs :: Name -> Idris Doc
docData :: Name -> TypeInfo -> Idris Doc
docClass :: Name -> ClassInfo -> Idris Doc
docFun :: Name -> Idris FunDoc
instance Show Doc
instance Show FunDoc

module Idris.Providers

-- | Wrap a type provider in the type of type providers
providerTy :: FC -> PTerm -> PTerm

-- | Handle an error, if the type provider returned an error. Otherwise
--   return the provided term.
getProvided :: TT Name -> Idris (TT Name)

module Idris.ElabDecls
recheckC :: FC -> Env -> TT Name -> StateT IState (ErrorT Err IO) (Term, Type)
checkDef :: FC -> [(t, (t1, t2, TT Name))] -> StateT IState (ErrorT Err IO) [(t, (t1, t2, Term))]

-- | Elaborate a top-level type declaration - for example, <a>foo : Int
--   -&gt; Int</a>.
elabType :: ElabInfo -> SyntaxInfo -> String -> FC -> FnOpts -> Name -> PTerm -> Idris Type
elabType' :: Bool -> ElabInfo -> SyntaxInfo -> String -> FC -> FnOpts -> Name -> PTerm -> Idris Type
elabPostulate :: ElabInfo -> SyntaxInfo -> String -> FC -> FnOpts -> Name -> PTerm -> Idris ()
elabData :: ElabInfo -> SyntaxInfo -> String -> FC -> Bool -> PData -> Idris ()

-- | Elaborate primitives
elabPrims :: Idris ()

-- | Elaborate a type provider
elabProvider :: ElabInfo -> SyntaxInfo -> FC -> Name -> PTerm -> PTerm -> Idris ()

-- | Elaborate a type provider
elabTransform :: ElabInfo -> FC -> Bool -> PTerm -> PTerm -> Idris ()
elabRecord :: ElabInfo -> SyntaxInfo -> String -> FC -> Name -> PTerm -> String -> Name -> PTerm -> Idris ()
elabCon :: ElabInfo -> SyntaxInfo -> Name -> Bool -> (String, Name, PTerm, FC) -> Idris (Name, Type)

-- | Elaborate a collection of left-hand and right-hand pairs - that is, a
--   top-level definition.
elabClauses :: ElabInfo -> FC -> FnOpts -> Name -> [PClause] -> Idris ()
elabPE :: ElabInfo -> FC -> Name -> Term -> Idris ()
elabValBind :: ElabInfo -> Bool -> PTerm -> Idris (Term, Type, [(Name, Type)])
elabVal :: ElabInfo -> Bool -> PTerm -> Idris (Term, Type)
checkPossible :: ElabInfo -> FC -> Bool -> Name -> PTerm -> Idris Bool
elabClause :: ElabInfo -> FnOpts -> (Int, PClause) -> Idris (Either Term (Term, Term))
data MArgTy
IA :: MArgTy
EA :: MArgTy
CA :: MArgTy
elabClass :: ElabInfo -> SyntaxInfo -> String -> FC -> [PTerm] -> Name -> [(Name, PTerm)] -> [PDecl] -> Idris ()
elabInstance :: ElabInfo -> SyntaxInfo -> FC -> [PTerm] -> Name -> [PTerm] -> PTerm -> Maybe Name -> [PDecl] -> Idris ()
decorateid :: (Name -> Name) -> PDecl' PTerm -> PDecl' PTerm
pbinds :: TT Name -> StateT (ElabState aux) TC ()
pbty :: TT n -> TT n -> TT n
getPBtys :: TT t -> [(t, TT t)]
psolve :: TT t -> StateT (ElabState aux) TC ()
pvars :: IState -> TT Name -> [(Name, PTerm)]
data ElabWhat
ETypes :: ElabWhat
EDefns :: ElabWhat
EAll :: ElabWhat
elabDecls :: ElabInfo -> [PDecl] -> Idris ()
elabDecl :: ElabWhat -> ElabInfo -> PDecl -> Idris ()
elabDecl' :: ElabWhat -> ElabInfo -> PDecl' PTerm -> StateT IState (ErrorT Err IO) ()
elabCaseBlock :: ElabInfo -> [FnOpt] -> PDecl' PTerm -> StateT IState (ErrorT Err IO) ()
checkInferred :: FC -> PTerm -> PTerm -> Idris ()
inferredDiff :: FC -> PTerm -> PTerm -> Idris Bool
instance Show MArgTy
instance Show ElabWhat
instance Eq ElabWhat

module Idris.Parser

-- | Parses module definition ModuleHeader ::= 'module' Identifier_t ';'?;
moduleHeader :: IdrisParser [String]

-- | Parses an import statement Import ::= 'import' Identifier_t ';'?;
import_ :: IdrisParser String

-- | Parses program source Prog ::= Decl* EOF;
prog :: SyntaxInfo -> IdrisParser [PDecl]
decl :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a top-level declaration with possible syntax sugar Decl' ::=
--   Fixity | FunDecl' | Data | Record | SyntaxDecl ;
decl' :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a syntax extension declaration (and adds the rule to parser
--   state) SyntaxDecl ::= SyntaxRule;
syntaxDecl :: SyntaxInfo -> IdrisParser PDecl
syntaxRule :: SyntaxInfo -> IdrisParser Syntax

-- | Parses a syntax symbol (either binding variable, keyword or
--   expression) SyntaxSym ::= '[' Name_t ']' | '{' Name_t '}' | Name_t |
--   StringLiteral_t ;
syntaxSym :: IdrisParser SSymbol

-- | Parses a function declaration with possible syntax sugar FunDecl ::=
--   FunDecl';
fnDecl :: SyntaxInfo -> IdrisParser [PDecl]
fnDecl' :: SyntaxInfo -> IdrisParser PDecl
fnOpts :: [FnOpt] -> IdrisParser [FnOpt]

-- | Parses a postulate
--   
--   Postulate ::= DocComment_t? <a>postulate</a> FnOpts* Accesibility?
--   FnOpts* FnName TypeSig Terminator ;
postulate :: SyntaxInfo -> IdrisParser PDecl

-- | Parses a using declaration
--   
--   Using ::= <a>using</a> '(' UsingDeclList ')' OpenBlock Decl*
--   CloseBlock ;
using_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a parameters declaration
--   
--   Params ::= <tt>parameters</tt> '(' TypeDeclList ')' OpenBlock Decl*
--   CloseBlock ;
params :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a mutual declaration (for mutually recursive functions)
--   
--   Mutual ::= <a>mutual</a> OpenBlock Decl* CloseBlock ;
mutual :: SyntaxInfo -> IdrisParser [PDecl]
namespace :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a methods block (for type classes and instances) MethodsBlock
--   ::= 'where' OpenBlock FnDecl* CloseBlock
methodsBlock :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a type class declaration
--   
--   ClassArgument ::= Name | '(' Name <tt>:</tt> Expr ')' ;
--   
--   Class ::= DocComment_t? Accessibility? 'class' ConstraintList? Name
--   ClassArgument* MethodsBlock? ;
class_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a type class instance declaration
--   
--   Instance ::= 'instance' InstanceName? ConstraintList? Name SimpleExpr*
--   MethodsBlock? ;
--   
--   InstanceName ::= '[' Name ']';
instance_ :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a using declaration list UsingDeclList ::= UsingDeclList' |
--   NameList TypeSig ;
--   
--   UsingDeclList' ::= UsingDecl | UsingDecl ',' UsingDeclList' ;
--   
--   NameList ::= Name | Name ',' NameList ;
usingDeclList :: SyntaxInfo -> IdrisParser [Using]

-- | Parses a using declaration UsingDecl ::= FnName TypeSig | FnName
--   FnName+ ;
usingDecl :: SyntaxInfo -> IdrisParser Using

-- | Parse a clause with patterns Pattern ::= Clause;
pattern :: SyntaxInfo -> IdrisParser PDecl

-- | Parse a constant applicative form declaration CAF ::= 'let' FnName '='
--   Expr Terminator;
caf :: SyntaxInfo -> IdrisParser PDecl

-- | Parse an argument expression ArgExpr ::= HSimpleExpr | ;
argExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parse a right hand side of a function RHS ::= '=' Expr | <tt>?=</tt>
--   RHSName? Expr | <tt>impossible</tt> ;
--   
--   RHSName ::= '{' FnName '}';
rhs :: SyntaxInfo -> Name -> IdrisParser PTerm

-- | Parses a function clause RHSOrWithBlock ::= RHS WhereOrTerminator |
--   <tt>with</tt> SimpleExpr OpenBlock FnDecl+ CloseBlock ; Clause ::=
--   WExpr+ RHSOrWithBlock | SimpleExpr <tt>&lt;==</tt> FnName RHS
--   WhereOrTerminator | ArgExpr Operator ArgExpr WExpr* RHSOrWithBlock |
--   FnName ConstraintArg* ImplicitOrArgExpr* WExpr* RHSOrWithBlock ;
--   ImplicitOrArgExpr ::= ImplicitArg | ArgExpr; WhereOrTerminator ::=
--   WhereBlock | Terminator;
clause :: SyntaxInfo -> IdrisParser PClause
wExpr :: SyntaxInfo -> IdrisParser PTerm

-- | Parses a where block WhereBlock ::= 'where' OpenBlock Decl+
--   CloseBlock;
whereBlock :: Name -> SyntaxInfo -> IdrisParser ([PDecl], [(Name, Name)])

-- | Parses a code generation target language name Codegen ::= <tt>C</tt> |
--   <tt>Java</tt> | <tt>JavaScript</tt> | <tt>Node</tt> | <tt>LLVM</tt> |
--   <a>Bytecode</a> ;
codegen_ :: IdrisParser Codegen

-- | Parses a compiler directive StringList ::= String | String ','
--   StringList ;
--   
--   Directive ::= <tt>%</tt> Directive';
--   
--   Directive' ::= <tt>lib</tt> CodeGen String_t | <tt>link</tt> CodeGen
--   String_t | <tt>flag</tt> CodeGen String_t | <tt>include</tt> CodeGen
--   String_t | <tt>hide</tt> Name | <tt>freeze</tt> Name | <tt>access</tt>
--   Accessibility | 'default' Totality | <tt>logging</tt> Natural |
--   <tt>dynamic</tt> StringList | <tt>language</tt> <a>TypeProviders</a> |
--   <tt>language</tt> <a>ErrorReflection</a> ;
directive :: SyntaxInfo -> IdrisParser [PDecl]
pLangExt :: IdrisParser LanguageExt

-- | Parses a totality Totality ::= <tt>partial</tt> | <tt>total</tt>
totality :: IdrisParser Bool

-- | Parses a type provider Provider ::= <tt>%</tt> <tt>provide</tt> '('
--   FnName TypeSig ')' <tt>with</tt> Expr;
provider :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses a transform Transform ::= <tt>%</tt> <a>transform</a> Expr
--   <tt>==&gt;</tt> Expr
transform :: SyntaxInfo -> IdrisParser [PDecl]

-- | Parses an expression from input
parseExpr :: IState -> String -> Result PTerm

-- | Parses a tactic from input
parseTactic :: IState -> String -> Result PTactic

-- | Parse module header and imports
parseImports :: FilePath -> String -> Idris ([String], [String], Maybe Delta)

-- | There should be a better way of doing this...
findFC :: Doc -> (FC, String)

-- | A program is a list of declarations, possibly with associated
--   documentation strings.
parseProg :: SyntaxInfo -> FilePath -> String -> Maybe Delta -> Idris [PDecl]

-- | Load idris module and show error if something wrong happens
loadModule :: Handle -> FilePath -> Idris String

-- | Load idris module
loadModule' :: Handle -> FilePath -> Idris String

-- | Load idris code from file
loadFromIFile :: Handle -> IFileType -> Idris ()

-- | Load idris source code and show error if something wrong happens
loadSource' :: Handle -> Bool -> FilePath -> Idris ()

-- | Load Idris source code
loadSource :: Handle -> Bool -> FilePath -> Idris ()

-- | Adds names to hide list
addHides :: [(Name, Maybe Accessibility)] -> Idris ()

module Idris.Chaser
buildTree :: [FilePath] -> FilePath -> Idris [ModuleTree]
getModuleFiles :: [ModuleTree] -> [IFileType]
data ModuleTree
MTree :: IFileType -> Bool -> UTCTime -> [ModuleTree] -> ModuleTree
mod_path :: ModuleTree -> IFileType
mod_needsRecheck :: ModuleTree -> Bool
mod_time :: ModuleTree -> UTCTime
mod_deps :: ModuleTree -> [ModuleTree]
instance Show ModuleTree

module Idris.REPLParser
parseCmd :: IState -> String -> String -> Result Command

module Idris.CaseSplit
splitOnLine :: Int -> Name -> FilePath -> Idris [[(Name, PTerm)]]
replaceSplits :: String -> [[(Name, PTerm)]] -> Idris [String]
getClause :: Int -> Name -> FilePath -> Idris String
getProofClause :: Int -> Name -> FilePath -> Idris String
mkWith :: String -> Name -> String
getUniq :: (Num t, Show t) => [Char] -> t -> StateT IState (ErrorT Err IO) ([Char], t)
nameRoot :: [String] -> [Char] -> String

module Idris.Prover
prover :: Bool -> Name -> Idris ()
showProof :: Bool -> Name -> [String] -> String
proverSettings :: ElabState [PDecl] -> Settings Idris
assumptionNames :: ElabState [PDecl] -> [String]
prove :: Context -> Bool -> Name -> Type -> Idris ()
elabStep :: ElabState [PDecl] -> ElabD a -> Idris (a, ElabState [PDecl])
dumpState :: IState -> ProofState -> Idris ()
lifte :: ElabState [PDecl] -> ElabD a -> Idris a
receiveInput :: ElabState [PDecl] -> Idris (Maybe String)
ploop :: Bool -> String -> [String] -> ElabState [PDecl] -> Maybe History -> Idris (Term, [String])

module Util.LLVMStubs
getDefaultTargetTriple :: IO String
getHostCPUName :: IO String
codegenLLVM :: [(Name, SDecl)] -> String -> String -> Word -> FilePath -> OutputType -> IO ()

module IRTS.BCImp
data Reg
RVal :: Reg
L :: Int -> Reg
data BC
NOP :: BC
toBC :: (Name, SDecl) -> (Name, [BC])
bc :: Reg -> SExp -> [BC]

module IRTS.Bytecode
data Reg
RVal :: Reg
L :: Int -> Reg
T :: Int -> Reg
Tmp :: Reg
data BC
ASSIGN :: Reg -> Reg -> BC
ASSIGNCONST :: Reg -> Const -> BC
UPDATE :: Reg -> Reg -> BC
MKCON :: Reg -> Int -> [Reg] -> BC
CASE :: Bool -> Reg -> [(Int, [BC])] -> (Maybe [BC]) -> BC
PROJECT :: Reg -> Int -> Int -> BC
PROJECTINTO :: Reg -> Reg -> Int -> BC
CONSTCASE :: Reg -> [(Const, [BC])] -> (Maybe [BC]) -> BC
CALL :: Name -> BC
TAILCALL :: Name -> BC
FOREIGNCALL :: Reg -> FLang -> FType -> String -> [(FType, Reg)] -> BC
SLIDE :: Int -> BC
REBASE :: BC
RESERVE :: Int -> BC
ADDTOP :: Int -> BC
TOPBASE :: Int -> BC
BASETOP :: Int -> BC
STOREOLD :: BC
OP :: Reg -> PrimFn -> [Reg] -> BC
NULL :: Reg -> BC
ERROR :: String -> BC
toBC :: (Name, SDecl) -> (Name, [BC])
clean :: Bool -> [BC]
bc :: Reg -> SExp -> Bool -> [BC]
isConst :: [SAlt] -> Bool
moveReg :: Int -> [LVar] -> [BC]
assign :: Reg -> Reg -> [BC]
conCase :: Bool -> Reg -> Reg -> [SAlt] -> Bool -> [BC]
constCase :: Reg -> Reg -> [SAlt] -> Bool -> [BC]
caseAlt :: Reg -> Reg -> Bool -> SAlt -> Maybe (Int, [BC])
constAlt :: t -> Reg -> Bool -> SAlt -> Maybe (Const, [BC])
defaultAlt :: Reg -> [SAlt] -> Bool -> Maybe [BC]
instance Show Reg
instance Eq Reg
instance Show BC

module IRTS.CodegenC
codegenC :: [(Name, SDecl)] -> String -> OutputType -> [FilePath] -> String -> String -> String -> DbgLevel -> IO ()

module IRTS.Java.Mangling
prefixCallNamespaces :: Ident -> SDecl -> SDecl
liftParsed :: (Show e, MonadError String m) => Either e a -> m a
mkClassName :: MonadError String m => FilePath -> m Ident
mangleWithPrefix :: (Applicative m, MonadError String m) => String -> Name -> m Ident
mangle :: (Applicative m, MonadError String m) => Name -> m Ident
mangle' :: Name -> Ident
mangleFull :: (Applicative m, MonadError String m) => Name -> m Name

module IRTS.CodegenJava
codegenJava :: [(Name, SExp)] -> [(Name, SDecl)] -> FilePath -> [String] -> [String] -> OutputType -> IO ()

module IRTS.CodegenJavaScript
codegenJavaScript :: JSTarget -> [(Name, SDecl)] -> FilePath -> OutputType -> IO ()
data JSTarget
Node :: JSTarget
JavaScript :: JSTarget
instance Eq JSTarget
instance Eq JSType
instance Eq JSInteger
instance Eq JSNum
instance Eq JS
instance Eq CaseType

module IRTS.DumpBC
interMap :: [a] -> [b] -> (a -> [b]) -> [b]
indent :: Int -> String
serializeReg :: Reg -> String
serializeCase :: Show a => Int -> (a, [BC]) -> String
serializeDefault :: Int -> [BC] -> String
serializeBC :: Int -> BC -> String
serialize :: [(Name, [BC])] -> String
dumpBC :: [(Name, SDecl)] -> String -> IO ()

module IRTS.Inliner
inline :: DDefs -> DDefs
inl :: DDefs -> (Name, DDecl) -> (Name, DDecl)
evalD :: t -> a -> Maybe a

module IRTS.Compiler
compile :: Codegen -> FilePath -> Term -> Idris ()
irMain :: TT Name -> Idris LDecl
mkDecls :: Term -> [Name] -> Idris [(Name, LDecl)]
showCaseTrees :: [(Name, LDecl)] -> String
isCon :: Def -> Bool
class ToIR a
ir :: ToIR a => a -> Idris LExp
build :: (Name, Def) -> Idris (Name, LDecl)
getPrim :: IState -> Name -> [LExp] -> Maybe LExp
declArgs :: [Name] -> Bool -> Name -> LExp -> LDecl
mkLDecl :: Name -> Def -> StateT IState (ErrorT Err IO) LDecl
getFTypes :: TT Name -> Maybe [FType]
mkIty' :: TT Name -> FType
mkIty :: [Char] -> FType
mkIntIty :: [Char] -> FType
zname :: Name
sname :: Name
instance ToIR SC
instance ToIR ([Name], SC)
instance ToIR (TT Name)

module Idris.REPL

-- | Run the REPL
repl :: IState -> MVar IState -> [FilePath] -> InputT Idris ()

-- | Run the REPL server
startServer :: IState -> MVar IState -> [FilePath] -> Idris ()
processNetCmd :: MVar IState -> IState -> IState -> Handle -> FilePath -> String -> IO (IState, FilePath)

-- | Run a command on the server on localhost
runClient :: String -> IO ()

-- | Run the IdeSlave
ideslaveStart :: IState -> [FilePath] -> Idris ()
ideslave :: IState -> [FilePath] -> Idris ()
ideslaveProcess :: FilePath -> Command -> Idris ()

-- | The prompt consists of the currently loaded modules, or <a>Idris</a>
--   if there are none
mkPrompt :: [FilePath] -> [Char]

-- | Determine whether a file uses literate syntax
lit :: FilePath -> Bool
processInput :: MVar IState -> String -> IState -> [FilePath] -> Idris (Maybe [FilePath])
resolveProof :: Name -> Idris Name
removeProof :: Name -> Idris ()
edit :: FilePath -> IState -> Idris ()
proofs :: IState -> Idris ()
insertScript :: String -> [String] -> [String]
process :: Handle -> FilePath -> Command -> Idris ()
classInfo :: ClassInfo -> Idris ()
dumpMethod :: (Name, (FnOpts, PTerm)) -> Idris ()
dumpInstance :: Name -> Idris ()
showTotal :: Totality -> IState -> String
showTotalN :: IState -> Name -> String
displayHelp :: [Char]
parseCodegen :: String -> Codegen
parseArgs :: [String] -> [Opt]
helphead :: [([[Char]], CmdArg, [Char])]
replSettings :: Maybe FilePath -> Settings Idris
idris :: [Opt] -> IO ()
loadInputs :: Handle -> [FilePath] -> Idris ()
idrisMain :: [Opt] -> Idris ()
execScript :: String -> Idris ()

-- | Check if the coloring matches the options and corrects if necessary
fixColour :: Bool -> Doc -> Doc

-- | Get the platform-specific, user-specific Idris dir
getIdrisUserDataDir :: Idris FilePath

-- | Locate the platform-specific location for the init script
getInitScript :: Idris FilePath

-- | Run the initialisation script
initScript :: Idris ()
getFile :: Opt -> Maybe String
getBC :: Opt -> Maybe String
getOutput :: Opt -> Maybe String
getIBCSubDir :: Opt -> Maybe String
getImportDir :: Opt -> Maybe String
getPkgDir :: Opt -> Maybe String
getPkg :: Opt -> Maybe (Bool, String)
getPkgClean :: Opt -> Maybe String
getCodegen :: Opt -> Maybe Codegen
getExecScript :: Opt -> Maybe String
getOutputTy :: Opt -> Maybe OutputType
getLanguageExt :: Opt -> Maybe LanguageExt
getTriple :: Opt -> Maybe String
getCPU :: Opt -> Maybe String
getOptLevel :: Opt -> Maybe Word
getColour :: Opt -> Maybe Bool
opt :: (Opt -> Maybe a) -> [Opt] -> [a]
ver :: String
banner :: [Char]

module Pkg.PParser
type PParser = StateT PkgDesc IdrisInnerParser
data PkgDesc
PkgDesc :: String -> [String] -> [String] -> Maybe String -> [Opt] -> String -> [Name] -> Name -> Maybe String -> PkgDesc
pkgname :: PkgDesc -> String
libdeps :: PkgDesc -> [String]
objs :: PkgDesc -> [String]
makefile :: PkgDesc -> Maybe String
idris_opts :: PkgDesc -> [Opt]
sourcedir :: PkgDesc -> String
modules :: PkgDesc -> [Name]
idris_main :: PkgDesc -> Name
execout :: PkgDesc -> Maybe String
defaultPkg :: PkgDesc
parseDesc :: FilePath -> IO PkgDesc
pPkg :: PParser PkgDesc
pClause :: PParser ()
instance Show PkgDesc

module Pkg.Package
buildPkg :: Bool -> (Bool, FilePath) -> IO ()
cleanPkg :: FilePath -> IO ()
installPkg :: PkgDesc -> IO ()
buildMods :: [Opt] -> [Name] -> IO ()
testLib :: Bool -> String -> String -> IO Bool
rmIBC :: Name -> IO ()
toIBCFile :: Name -> [Char]
installIBC :: String -> Name -> IO ()
installObj :: String -> String -> IO ()
mkDirCmd :: [Char]
make :: Maybe String -> IO ()
clean :: Maybe String -> IO ()

module Main
main :: IO ()
runIdris :: [Opt] -> Idris ()
usage :: IO b
showver :: IO b
showLibs :: IO b
showLibdir :: IO b
showIncs :: IO b
usagemsg :: [Char]
